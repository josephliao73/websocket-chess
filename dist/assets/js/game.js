/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: () => (/* binding */ BISHOP),\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   DEFAULT_POSITION: () => (/* binding */ DEFAULT_POSITION),\n/* harmony export */   KING: () => (/* binding */ KING),\n/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),\n/* harmony export */   PAWN: () => (/* binding */ PAWN),\n/* harmony export */   QUEEN: () => (/* binding */ QUEEN),\n/* harmony export */   ROOK: () => (/* binding */ ROOK),\n/* harmony export */   SQUARES: () => (/* binding */ SQUARES),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   validateFen: () => (/* binding */ validateFen)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\n// prettier-ignore\nconst SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n};\n// prettier-ignore\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n// prettier-ignore\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE\n};\nconst ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n  return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n  return square & 0xf;\n}\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n  const f = file(square);\n  const r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction swapColor(color) {\n  return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: `Invalid FEN: missing ${color} king`\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: `Invalid FEN: too many ${color} kings`\n      };\n    }\n  }\n  return {\n    ok: true\n  };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n  const from = move.from;\n  const to = move.to;\n  const piece = move.piece;\n  let ambiguities = 0;\n  let sameRank = 0;\n  let sameFile = 0;\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from;\n    const ambigTo = moves[i].to;\n    const ambigPiece = moves[i].piece;\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0);\n    }\n  }\n  return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n  const r = rank(to);\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i];\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags\n    });\n  }\n}\nfunction inferPieceType(san) {\n  let pieceType = san.charAt(0);\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n    if (matches) {\n      return undefined;\n    }\n    return PAWN;\n  }\n  pieceType = pieceType.toLowerCase();\n  if (pieceType === 'o') {\n    return KING;\n  }\n  return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n  _board = new Array(128);\n  _turn = WHITE;\n  _header = {};\n  _kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  _epSquare = -1;\n  _halfMoves = 0;\n  _moveNumber = 0;\n  _history = [];\n  _comments = {};\n  _castling = {\n    w: 0,\n    b: 0\n  };\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen);\n  }\n  clear(keepHeaders = false) {\n    this._board = new Array(128);\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._turn = WHITE;\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this._epSquare = EMPTY;\n    this._halfMoves = 0;\n    this._moveNumber = 1;\n    this._history = [];\n    this._comments = {};\n    this._header = keepHeaders ? this._header : {};\n    this._updateSetup(this.fen());\n  }\n  removeHeader(key) {\n    if (key in this._header) {\n      delete this._header[key];\n    }\n  }\n  load(fen, keepHeaders = false) {\n    let tokens = fen.split(/\\s+/);\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1'];\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n    }\n    tokens = fen.split(/\\s+/);\n    const {\n      ok,\n      error\n    } = validateFen(fen);\n    if (!ok) {\n      throw new Error(error);\n    }\n    const position = tokens[0];\n    let square = 0;\n    this.clear(keepHeaders);\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i);\n      if (piece === '/') {\n        square += 8;\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK;\n        this.put({\n          type: piece.toLowerCase(),\n          color\n        }, algebraic(square));\n        square++;\n      }\n    }\n    this._turn = tokens[1];\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE;\n    }\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n    this._halfMoves = parseInt(tokens[4], 10);\n    this._moveNumber = parseInt(tokens[5], 10);\n    this._updateSetup(this.fen());\n  }\n  fen() {\n    let empty = 0;\n    let fen = '';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        const {\n          color,\n          type: piece\n        } = this._board[i];\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      } else {\n        empty++;\n      }\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n        if (i !== Ox88.h1) {\n          fen += '/';\n        }\n        empty = 0;\n        i += 8;\n      }\n    }\n    let castling = '';\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K';\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q';\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k';\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q';\n    }\n    // do we have an empty castling flag?\n    castling = castling || '-';\n    let epSquare = '-';\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue;\n        }\n        const color = this._turn;\n        // is there a pawn that can capture the epSquare?\n        if (this._board[square]?.color === color && this._board[square]?.type === PAWN) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE\n          });\n          const isLegal = !this._isKingAttacked(color);\n          this._undoMove();\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare);\n            break;\n          }\n        }\n      }\n    }\n    return [fen, this._turn, castling, epSquare, this._halfMoves, this._moveNumber].join(' ');\n  }\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  _updateSetup(fen) {\n    if (this._history.length > 0) return;\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1';\n      this._header['FEN'] = fen;\n    } else {\n      delete this._header['SetUp'];\n      delete this._header['FEN'];\n    }\n  }\n  reset() {\n    this.load(DEFAULT_POSITION);\n  }\n  get(square) {\n    return this._board[Ox88[square]] || false;\n  }\n  put({\n    type,\n    color\n  }, square) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false;\n    }\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false;\n    }\n    const sq = Ox88[square];\n    // don't let the user place more than one king\n    if (type == KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n      return false;\n    }\n    this._board[sq] = {\n      type: type,\n      color: color\n    };\n    if (type === KING) {\n      this._kings[color] = sq;\n    }\n    this._updateCastlingRights();\n    this._updateEnPassantSquare();\n    this._updateSetup(this.fen());\n    return true;\n  }\n  remove(square) {\n    const piece = this.get(square);\n    delete this._board[Ox88[square]];\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY;\n    }\n    this._updateCastlingRights();\n    this._updateEnPassantSquare();\n    this._updateSetup(this.fen());\n    return piece;\n  }\n  _updateCastlingRights() {\n    const whiteKingInPlace = this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE;\n    const blackKingInPlace = this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK;\n    if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE;\n    }\n    if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE;\n    }\n    if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE;\n    }\n    if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE;\n    }\n  }\n  _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return;\n    }\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n    const attackers = [currentSquare + 1, currentSquare - 1];\n    if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || this._board[currentSquare]?.color !== swapColor(this._turn) || this._board[currentSquare]?.type !== PAWN) {\n      this._epSquare = EMPTY;\n      return;\n    }\n    const canCapture = square => !(square & 0x88) && this._board[square]?.color === this._turn && this._board[square]?.type === PAWN;\n    if (!attackers.some(canCapture)) {\n      this._epSquare = EMPTY;\n    }\n  }\n  _attacked(color, square) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue;\n      }\n      const piece = this._board[i];\n      const difference = i - square;\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue;\n      }\n      const index = difference + 119;\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n          continue;\n        }\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        const offset = RAYS[index];\n        let j = i + offset;\n        let blocked = false;\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true;\n            break;\n          }\n          j += offset;\n        }\n        if (!blocked) return true;\n      }\n    }\n    return false;\n  }\n  _isKingAttacked(color) {\n    const square = this._kings[color];\n    return square === -1 ? false : this._attacked(swapColor(color), square);\n  }\n  isAttacked(square, attackedBy) {\n    return this._attacked(attackedBy, Ox88[square]);\n  }\n  isCheck() {\n    return this._isKingAttacked(this._turn);\n  }\n  inCheck() {\n    return this.isCheck();\n  }\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0;\n  }\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0;\n  }\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0\n    };\n    const bishops = [];\n    let numPieces = 0;\n    let squareColor = 0;\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2;\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      const piece = this._board[i];\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor);\n        }\n        numPieces++;\n      }\n    }\n    // k vs. k\n    if (numPieces === 2) {\n      return true;\n    } else if (\n    // k vs. kn .... or .... k vs. kb\n    numPieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0;\n      const len = bishops.length;\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isThreefoldRepetition() {\n    const moves = [];\n    const positions = {};\n    let repetition = false;\n    while (true) {\n      const move = this._undoMove();\n      if (!move) break;\n      moves.push(move);\n    }\n    while (true) {\n      /*\n       * remove the last two fields in the FEN string, they're not needed when\n       * checking for draw by rep\n       */\n      const fen = this.fen().split(' ').slice(0, 4).join(' ');\n      // has the position occurred three or move times\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n      const move = moves.pop();\n      if (!move) {\n        break;\n      } else {\n        this._makeMove(move);\n      }\n    }\n    return repetition;\n  }\n  isDraw() {\n    return this._halfMoves >= 100 ||\n    // 50 moves per side = 100 half moves\n    this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n  }\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw();\n  }\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined\n  } = {}) {\n    const moves = this._moves({\n      square,\n      piece\n    });\n    if (verbose) {\n      return moves.map(move => this._makePretty(move));\n    } else {\n      return moves.map(move => this._moveToSan(move, moves));\n    }\n  }\n  _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined\n  } = {}) {\n    const forSquare = square ? square.toLowerCase() : undefined;\n    const forPiece = piece?.toLowerCase();\n    const moves = [];\n    const us = this._turn;\n    const them = swapColor(us);\n    let firstSquare = Ox88.a8;\n    let lastSquare = Ox88.h1;\n    let singleSquare = false;\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return [];\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare];\n        singleSquare = true;\n      }\n    }\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7;\n        continue;\n      }\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue;\n      }\n      const {\n        type\n      } = this._board[from];\n      let to;\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue;\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0];\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN);\n          // double square\n          to = from + PAWN_OFFSETS[us][1];\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n          }\n        }\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j];\n          if (to & 0x88) continue;\n          if (this._board[to]?.color === them) {\n            addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue;\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j];\n          to = from;\n          while (true) {\n            to += offset;\n            if (to & 0x88) break;\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type);\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break;\n              addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break;\n          }\n        }\n      }\n    }\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom + 2;\n          if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n          }\n        }\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom - 2;\n          if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves;\n    }\n    // filter out illegal moves\n    const legalMoves = [];\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i]);\n      }\n      this._undoMove();\n    }\n    return legalMoves;\n  }\n  move(move, {\n    strict = false\n  } = {}) {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n    let moveObj = null;\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict);\n    } else if (typeof move === 'object') {\n      const moves = this._moves();\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n          moveObj = moves[i];\n          break;\n        }\n      }\n    }\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`);\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n      }\n    }\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = this._makePretty(moveObj);\n    this._makeMove(moveObj);\n    return prettyMove;\n  }\n  _push(move) {\n    this._history.push({\n      move,\n      kings: {\n        b: this._kings.b,\n        w: this._kings.w\n      },\n      turn: this._turn,\n      castling: {\n        b: this._castling.b,\n        w: this._castling.w\n      },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber\n    });\n  }\n  _makeMove(move) {\n    const us = this._turn;\n    const them = swapColor(us);\n    this._push(move);\n    this._board[move.to] = this._board[move.from];\n    delete this._board[move.from];\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16];\n      } else {\n        delete this._board[move.to + 16];\n      }\n    }\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to;\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1;\n        const castlingFrom = move.to + 1;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1;\n        const castlingFrom = move.to - 2;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      }\n      // turn off castling\n      this._castling[us] = 0;\n    }\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n          this._castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n          this._castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16;\n      } else {\n        this._epSquare = move.to + 16;\n      }\n    } else {\n      this._epSquare = EMPTY;\n    }\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0;\n    } else {\n      this._halfMoves++;\n    }\n    if (us === BLACK) {\n      this._moveNumber++;\n    }\n    this._turn = them;\n  }\n  undo() {\n    const move = this._undoMove();\n    return move ? this._makePretty(move) : null;\n  }\n  _undoMove() {\n    const old = this._history.pop();\n    if (old === undefined) {\n      return null;\n    }\n    const move = old.move;\n    this._kings = old.kings;\n    this._turn = old.turn;\n    this._castling = old.castling;\n    this._epSquare = old.epSquare;\n    this._halfMoves = old.halfMoves;\n    this._moveNumber = old.moveNumber;\n    const us = this._turn;\n    const them = swapColor(us);\n    this._board[move.from] = this._board[move.to];\n    this._board[move.from].type = move.piece; // to undo any promotions\n    delete this._board[move.to];\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index;\n        if (us === BLACK) {\n          index = move.to - 16;\n        } else {\n          index = move.to + 16;\n        }\n        this._board[index] = {\n          type: PAWN,\n          color: them\n        };\n      } else {\n        // regular capture\n        this._board[move.to] = {\n          type: move.captured,\n          color: them\n        };\n      }\n    }\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo, castlingFrom;\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1;\n        castlingFrom = move.to - 1;\n      } else {\n        castlingTo = move.to - 2;\n        castlingFrom = move.to + 1;\n      }\n      this._board[castlingTo] = this._board[castlingFrom];\n      delete this._board[castlingFrom];\n    }\n    return move;\n  }\n  pgn({\n    newline = '\\n',\n    maxWidth = 0\n  } = {}) {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n    const result = [];\n    let headerExists = false;\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n      headerExists = true;\n    }\n    if (headerExists && this._history.length) {\n      result.push(newline);\n    }\n    const appendComment = moveString => {\n      const comment = this._comments[this.fen()];\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : '';\n        moveString = `${moveString}${delimiter}{${comment}}`;\n      }\n      return moveString;\n    };\n    // pop all of history onto reversed_history\n    const reversedHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    const moves = [];\n    let moveString = '';\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''));\n    }\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString);\n      const move = reversedHistory.pop();\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break;\n      }\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`;\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix;\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString);\n        }\n        moveString = this._moveNumber + '.';\n      }\n      moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n        legal: true\n      }));\n      this._makeMove(move);\n    }\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString));\n    }\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result);\n    }\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ');\n    }\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop();\n        return true;\n      }\n      return false;\n    };\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width, move) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue;\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--;\n          }\n          result.push(newline);\n          width = 0;\n        }\n        result.push(token);\n        width += token.length;\n        result.push(' ');\n        width++;\n      }\n      if (strip()) {\n        width--;\n      }\n      return width;\n    };\n    // wrap the PGN output at max_width\n    let currentWidth = 0;\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i]);\n          continue;\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop();\n        }\n        result.push(newline);\n        currentWidth = 0;\n      } else if (i !== 0) {\n        result.push(' ');\n        currentWidth++;\n      }\n      result.push(moves[i]);\n      currentWidth += moves[i].length;\n    }\n    return result.join('');\n  }\n  header(...args) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1];\n      }\n    }\n    return this._header;\n  }\n  loadPgn(pgn, {\n    strict = false,\n    newlineChar = '\\r?\\n'\n  } = {}) {\n    function mask(str) {\n      return str.replace(/\\\\/g, '\\\\');\n    }\n    function parsePgnHeader(header) {\n      const headerObj = {};\n      const headers = header.split(new RegExp(mask(newlineChar)));\n      let key = '';\n      let value = '';\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n        key = headers[i].replace(regex, '$1');\n        value = headers[i].replace(regex, '$2');\n        if (key.trim().length > 0) {\n          headerObj[key] = value;\n        }\n      }\n      return headerObj;\n    }\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim();\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '((?:\\\\s*' + mask(newlineChar) + '){2}|(?:\\\\s*' + mask(newlineChar) + ')*$)');\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn);\n    const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : '';\n    // Put the board in the starting position\n    this.reset();\n    // parse PGN header\n    const headers = parsePgnHeader(headerString);\n    let fen = '';\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key];\n      }\n      this.header(key, headers[key]);\n    }\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, true);\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n        }\n        // second argument to load: don't clear the headers\n        this.load(headers['FEN'], true);\n      }\n    }\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n    function toHex(s) {\n      return Array.from(s).map(function (c) {\n        /*\n         * encodeURI doesn't transform most ASCII characters, so we handle\n         * these ourselves\n         */\n        return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n      }).join('');\n    }\n    function fromHex(s) {\n      return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n    }\n    const encodeComment = function (s) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      return `{${toHex(s.slice(1, s.length - 1))}}`;\n    };\n    const decodeComment = function (s) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1));\n      }\n    };\n    // delete header to get the moves\n    let ms = pgn.replace(headerString, '').replace(\n    // encode comments so they don't get deleted below\n    new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n      return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n    }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g;\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '');\n    }\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '');\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '');\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/));\n    // delete empty entries\n    moves = moves.filter(move => move !== '');\n    let result = '';\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove]);\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment;\n        continue;\n      }\n      const move = this._moveFromSan(moves[halfMove], strict);\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove];\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = '';\n        this._makeMove(move);\n      }\n    }\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result);\n    }\n  }\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  _moveToSan(move, moves) {\n    let output = '';\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n        output += 'x';\n      }\n      output += algebraic(move.to);\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n    this._makeMove(move);\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n    this._undoMove();\n    return output;\n  }\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  _moveFromSan(move, strict = false) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move);\n    let pieceType = inferPieceType(cleanMove);\n    let moves = this._moves({\n      legal: true,\n      piece: pieceType\n    });\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i];\n      }\n    }\n    // the strict parser failed\n    if (strict) {\n      return null;\n    }\n    let piece = undefined;\n    let matches = undefined;\n    let from = undefined;\n    let to = undefined;\n    let promotion = undefined;\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n    let overlyDisambiguated = false;\n    matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n    //     piece         from              to       promotion\n    );\n\n    if (matches) {\n      piece = matches[1];\n      from = matches[2];\n      to = matches[3];\n      promotion = matches[4];\n      if (from.length == 1) {\n        overlyDisambiguated = true;\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      }\n    }\n    pieceType = inferPieceType(cleanMove);\n    moves = this._moves({\n      legal: true,\n      piece: piece ? piece : pieceType\n    });\n    if (!to) {\n      return null;\n    }\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n          return moves[i];\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n        return moves[i];\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n        const square = algebraic(moves[i].from);\n        if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        }\n      }\n    }\n    return null;\n  }\n  ascii() {\n    let s = '   +------------------------+\\n';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      if (this._board[i]) {\n        const piece = this._board[i].type;\n        const color = this._board[i].color;\n        const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      } else {\n        s += ' . ';\n      }\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h';\n    return s;\n  }\n  perft(depth) {\n    const moves = this._moves({\n      legal: false\n    });\n    let nodes = 0;\n    const color = this._turn;\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1);\n        } else {\n          nodes++;\n        }\n      }\n      this._undoMove();\n    }\n    return nodes;\n  }\n  // pretty = external move object\n  _makePretty(uglyMove) {\n    const {\n      color,\n      piece,\n      from,\n      to,\n      flags,\n      captured,\n      promotion\n    } = uglyMove;\n    let prettyFlags = '';\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag];\n      }\n    }\n    const fromAlgebraic = algebraic(from);\n    const toAlgebraic = algebraic(to);\n    const move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({\n        legal: true\n      })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic,\n      before: this.fen(),\n      after: ''\n    };\n    // generate the FEN for the 'after' key\n    this._makeMove(uglyMove);\n    move.after = this.fen();\n    this._undoMove();\n    if (captured) {\n      move.captured = captured;\n    }\n    if (promotion) {\n      move.promotion = promotion;\n      move.lan += promotion;\n    }\n    return move;\n  }\n  turn() {\n    return this._turn;\n  }\n  board() {\n    const output = [];\n    let row = [];\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null);\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color\n        });\n      }\n      if (i + 1 & 0x88) {\n        output.push(row);\n        row = [];\n        i += 8;\n      }\n    }\n    return output;\n  }\n  squareColor(square) {\n    if (square in Ox88) {\n      const sq = Ox88[square];\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n    }\n    return null;\n  }\n  history({\n    verbose = false\n  } = {}) {\n    const reversedHistory = [];\n    const moveHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      if (verbose) {\n        moveHistory.push(this._makePretty(move));\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()));\n      }\n      this._makeMove(move);\n    }\n    return moveHistory;\n  }\n  _pruneComments() {\n    const reversedHistory = [];\n    const currentComments = {};\n    const copyComment = fen => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen];\n      }\n    };\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    copyComment(this.fen());\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      this._makeMove(move);\n      copyComment(this.fen());\n    }\n    this._comments = currentComments;\n  }\n  getComment() {\n    return this._comments[this.fen()];\n  }\n  setComment(comment) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n  }\n  deleteComment() {\n    const comment = this._comments[this.fen()];\n    delete this._comments[this.fen()];\n    return comment;\n  }\n  getComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      return {\n        fen: fen,\n        comment: this._comments[fen]\n      };\n    });\n  }\n  deleteComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      const comment = this._comments[fen];\n      delete this._comments[fen];\n      return {\n        fen: fen,\n        comment: comment\n      };\n    });\n  }\n  setCastlingRights(color, rights) {\n    for (const side of [KING, QUEEN]) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side];\n        } else {\n          this._castling[color] &= ~SIDES[side];\n        }\n      }\n    }\n    this._updateCastlingRights();\n    const result = this.getCastlingRights(color);\n    return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n  }\n  getCastlingRights(color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0\n    };\n  }\n  moveNumber() {\n    return this._moveNumber;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/chess.js/dist/esm/chess.js?");

/***/ }),

/***/ "./src/chess/animations.js":
/*!*********************************!*\
  !*** ./src/chess/animations.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animateHistory: () => (/* binding */ animateHistory),\n/* harmony export */   animatePiece: () => (/* binding */ animatePiece),\n/* harmony export */   \"default\": () => (/* binding */ animateMove)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./src/chess/board.js\");\n/* harmony import */ var _notation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notation.js */ \"./src/chess/notation.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_board_js__WEBPACK_IMPORTED_MODULE_0__]);\n_board_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Default speed (going through history)\nvar speed = 1;\n// Speed when a new move is made\nvar moveSpeed = 0.8;\nfunction animateHistory(chessGame, prevHistory) {\n  var current = chessGame.history.length;\n  var history = chessGame.timeline;\n  if (history === prevHistory) {\n    return;\n  }\n  var game = history !== 0 ? chessGame.history[current - history] : chessGame;\n  game.showingWhiteSide = chessGame.showingWhiteSide;\n  // If the move isn't one move ahead/behind\n  if (Math.abs(prevHistory - history) !== 1) {\n    if (history === 0) {\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame);\n      return;\n    }\n    if (history === current) {\n      chessGame.history[0].showingWhiteSide = chessGame.showingWhiteSide;\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame.history[0]);\n      return;\n    }\n    chessGame.history[chessGame.history.length - chessGame.timeline].showingWhiteSide = chessGame.showingWhiteSide;\n    (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame.history[chessGame.history.length - chessGame.timeline]);\n    return;\n  }\n  var begin;\n  var end;\n\n  // Left Arrow\n  if (history > prevHistory) {\n    begin = history === 1 ? chessGame.lastMove[0] : chessGame.history[current - history + 1].lastMove[0];\n    end = history === 1 ? chessGame.lastMove[1] : chessGame.history[current - history + 1].lastMove[1];\n  }\n  // Right Arrow\n  if (history < prevHistory) {\n    end = game.lastMove[0];\n    begin = game.lastMove[1];\n  }\n  var animating = chessGame.div.querySelector('.animating');\n  // Don't render animation if another board was already rendered\n  if (!animating) {\n    if (history < prevHistory) {\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.playSound)(game);\n    }\n    animatePiece(end, begin, game.div.firstChild).then(function () {\n      if (chessGame.timeline) {\n        chessGame.history[chessGame.history.length - chessGame.timeline].showingWhiteSide = chessGame.showingWhiteSide;\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame.history[chessGame.history.length - chessGame.timeline]);\n      } else {\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame);\n      }\n    })[\"catch\"](function (e) {\n      console.log(\"caught error\", e);\n    });\n  } else {\n    var sound = history < prevHistory;\n    if (chessGame.timeline) {\n      chessGame.history[chessGame.history.length - chessGame.timeline].showingWhiteSide = chessGame.showingWhiteSide;\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame.history[chessGame.history.length - chessGame.timeline]);\n      if (sound) {\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.playSound)(chessGame.history[chessGame.history.length - chessGame.timeline]);\n      }\n    } else {\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(chessGame);\n      if (sound) {\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.playSound)(chessGame);\n      }\n    }\n  }\n}\nfunction animateMove(game, fromX, fromY, toX, toY) {\n  var sound = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var promotion = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var clicked = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  if (game.board[fromX][fromY] && game.board[fromX][fromY].move(toX, toY, promotion ? promotion : undefined, clicked)) {\n    if (game.timeline !== 0) {\n      game.timeline = 0;\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game.history[game.history.length - 1]);\n    }\n    var start = (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertLocationToNotation)(fromX, fromY);\n    var end = (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertLocationToNotation)(toX, toY);\n    if (sound) {\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.playSound)(game);\n    }\n    animatePiece(start, end, game.div.firstChild, moveSpeed).then(function () {\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n    })[\"catch\"](function () {\n      (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n    });\n    return true;\n  }\n  return false;\n}\nfunction animatePiece(fromNotation, toNotation, boardDiv) {\n  var speedMultiplier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : speed;\n  var initialDiv = boardDiv.querySelector(\"[notation=\".concat(fromNotation, \"]\"));\n  var destination = boardDiv.querySelector(\"[notation=\".concat(toNotation, \"]\"));\n  var size = initialDiv.offsetWidth / 2;\n  var fromXloc = initialDiv.getBoundingClientRect().left + size;\n  var fromYloc = initialDiv.getBoundingClientRect().top + size;\n  var toXloc = destination.getBoundingClientRect().left + size;\n  var toYloc = destination.getBoundingClientRect().top + size;\n\n  // 1 speedMultipler = 1 square per second \n  var duration = Math.sqrt(Math.pow((fromXloc - toXloc) / size, 2) + Math.pow((fromYloc - toYloc) / size, 2)) * (1 / speedMultiplier) * 250;\n\n  // Threshold in squares where you want to stop moving by distance\n  var minSpeed = 1;\n\n  // Caps duration set minSpeed\n  duration = duration <= minSpeed * 100 / speedMultiplier ? duration : minSpeed * 100 / speedMultiplier;\n  var child = initialDiv.lastChild;\n  var error;\n  if (child) {\n    boardDiv.querySelectorAll(\".highlighted\").forEach(function (square) {\n      square.classList.remove(\"highlighted\");\n    });\n    boardDiv.querySelector(\"[notation=\".concat(fromNotation)).classList.add(\"highlighted\");\n    boardDiv.querySelector(\"[notation=\".concat(toNotation)).classList.add(\"highlighted\");\n    child.animate([{\n      transform: 'translate(0px, 0px)'\n    }, {\n      transform: \"translate(\".concat(toXloc - fromXloc, \"px, \").concat(toYloc - fromYloc, \"px)\")\n    }], {\n      duration: duration,\n      iterations: 1\n    });\n    child.classList.add('animating');\n  } else {\n    error = new Error(\"Nothing to animate from \".concat(fromNotation));\n  }\n  return new Promise(function (resolve, reject) {\n    if (error) {\n      reject(error);\n    }\n    // Send promise 10ms early to prevent ghosting\n    setTimeout(function () {\n      resolve();\n    }, duration - 10);\n  });\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/animations.js?");

/***/ }),

/***/ "./src/chess/board.js":
/*!****************************!*\
  !*** ./src/chess/board.js ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FENtoBoard: () => (/* binding */ FENtoBoard),\n/* harmony export */   animateGame: () => (/* binding */ animateGame),\n/* harmony export */   createGame: () => (/* binding */ createGame),\n/* harmony export */   fetchMove: () => (/* binding */ fetchMove),\n/* harmony export */   gametoFEN: () => (/* binding */ gametoFEN),\n/* harmony export */   importGame: () => (/* binding */ importGame),\n/* harmony export */   playSound: () => (/* binding */ playSound),\n/* harmony export */   postMove: () => (/* binding */ postMove),\n/* harmony export */   renderBoard: () => (/* binding */ renderBoard),\n/* harmony export */   waitForMove: () => (/* binding */ waitForMove)\n/* harmony export */ });\n/* harmony import */ var _pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pieces/piece.js */ \"./src/chess/pieces/piece.js\");\n/* harmony import */ var _notation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notation.js */ \"./src/chess/notation.js\");\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drag.js */ \"./src/chess/drag.js\");\n/* harmony import */ var _marking_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./marking.js */ \"./src/chess/marking.js\");\n/* harmony import */ var _animations_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./animations.js */ \"./src/chess/animations.js\");\n/* harmony import */ var _sounds_Move_ogg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sounds/Move.ogg */ \"./src/chess/sounds/Move.ogg\");\n/* harmony import */ var _sounds_Capture_ogg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sounds/Capture.ogg */ \"./src/chess/sounds/Capture.ogg\");\n/* harmony import */ var _sounds_Check_wav__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sounds/Check.wav */ \"./src/chess/sounds/Check.wav\");\n/* harmony import */ var _game_random_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../game/random.js */ \"./src/game/random.js\");\n/* harmony import */ var _modify_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modify.js */ \"./src/chess/modify.js\");\n/* harmony import */ var _game_main_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../game/main.js */ \"./src/game/main.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__, _drag_js__WEBPACK_IMPORTED_MODULE_2__, _animations_js__WEBPACK_IMPORTED_MODULE_4__, _modify_js__WEBPACK_IMPORTED_MODULE_9__, _game_main_js__WEBPACK_IMPORTED_MODULE_10__]);\n([_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__, _drag_js__WEBPACK_IMPORTED_MODULE_2__, _animations_js__WEBPACK_IMPORTED_MODULE_4__, _modify_js__WEBPACK_IMPORTED_MODULE_9__, _game_main_js__WEBPACK_IMPORTED_MODULE_10__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n\n\n\n\n\n\n\n\nvar sounds = {\n  \"place\": _sounds_Move_ogg__WEBPACK_IMPORTED_MODULE_5__,\n  \"capture\": _sounds_Capture_ogg__WEBPACK_IMPORTED_MODULE_6__,\n  \"check\": _sounds_Check_wav__WEBPACK_IMPORTED_MODULE_7__\n};\nfunction FENtoBoard(FENstring) {\n  var whiteUserSpan = document.createElement('span');\n  var blackUserSpan = document.createElement('span');\n  whiteUserSpan.classList.add('whiteUser');\n  blackUserSpan.classList.add('blackUser');\n  var chessGame = {\n    board: _toConsumableArray(Array(8)).map(function (e) {\n      return Array(8).fill(null);\n    }),\n    div: null,\n    whitesMove: true,\n    whiteState: {\n      shortCastle: false,\n      longCastle: false\n    },\n    blackState: {\n      shortCastle: false,\n      longCastle: false\n    },\n    history: [],\n    timeline: 0,\n    lastMove: null,\n    lastMoveSound: null,\n    drawnArrows: [],\n    userHighlights: [],\n    playerIsWhite: true,\n    showingWhiteSide: true,\n    fiftyMoveRule: 0,\n    \"export\": [FENstring],\n    whiteUserSpan: whiteUserSpan,\n    blackUserSpan: blackUserSpan\n  };\n  var pieces = {\n    \"p\": \"pawn\",\n    \"q\": \"queen\",\n    \"b\": \"bishop\",\n    \"n\": \"knight\",\n    \"r\": \"rook\",\n    \"k\": \"king\"\n  };\n  FENstring = FENstring.split(\" \");\n  var board = _toConsumableArray(FENstring[0].split(\"/\")).reverse();\n  board.forEach(function (row, i) {\n    row = row.replace(/\\d+/g, function (number) {\n      return \"#\".repeat(Number(number));\n    });\n    row.split(\"\").reverse().forEach(function (_char, j) {\n      var isWhite = _char === _char.toUpperCase();\n      if (_char !== \"#\") {\n        (0,_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pieces[_char.toLowerCase()], isWhite, i, j, chessGame);\n      }\n    });\n  });\n  chessGame.whitesMove = FENstring[1] === \"w\";\n  FENstring[2].split(\"\").forEach(function (_char2) {\n    if (_char2 === \"k\") {\n      chessGame.blackState.shortCastle = true;\n    }\n    if (_char2 === \"q\") {\n      chessGame.blackState.longCastle = true;\n    }\n    if (_char2 === \"K\") {\n      chessGame.whiteState.shortCastle = true;\n    }\n    if (_char2 === \"Q\") {\n      chessGame.whiteState.longCastle = true;\n    }\n  });\n  if (FENstring[3] !== \"-\") {\n    var loc = (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertNotationtoLocation)(FENstring[3]);\n    (0,_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"passant\", !chessGame.whitesMove, loc[0], loc[1], chessGame);\n  }\n  chessGame.fiftyMoveRule = Number(FENstring[4]);\n  return chessGame;\n}\nfunction gametoFEN(game) {\n  var pieces = {\n    \"pawn\": \"p\",\n    \"queen\": \"q\",\n    \"bishop\": \"b\",\n    \"knight\": \"n\",\n    \"rook\": \"r\",\n    \"king\": \"k\"\n  };\n  var number = 0;\n  var FEN = \"\";\n  var passantSquare;\n  _toConsumableArray(game.board).reverse().forEach(function (row, i) {\n    _toConsumableArray(row).reverse().forEach(function (square, j) {\n      if (square === null) {\n        number += 1;\n      }\n      if (square && square.name === \"passant\") {\n        number += 1;\n        passantSquare = [7 - i, 7 - j];\n      }\n      if (square && square.name !== \"passant\") {\n        var piece = pieces[square.name];\n        FEN += number ? number : \"\";\n        FEN += square.isWhite ? piece.toUpperCase() : piece;\n        number = 0;\n      }\n    });\n    FEN += number ? number : \"\";\n    number = 0;\n    FEN += \"/\";\n  });\n  FEN = FEN.substring(0, FEN.length - 1) + \" \";\n  FEN += game.whitesMove ? \"w \" : \"b \";\n  if (game.whiteState.shortCastle) {\n    FEN += \"K\";\n  }\n  if (game.whiteState.longCastle) {\n    FEN += \"Q\";\n  }\n  if (game.blackState.shortCastle) {\n    FEN += \"k\";\n  }\n  if (game.blackState.longCastle) {\n    FEN += \"q\";\n  }\n  if (!game.whiteState.shortCastle && !game.whiteState.longCastle && !game.blackState.shortCastle && !game.blackState.longCastle) {\n    FEN += \"-\";\n  }\n  FEN += \" \";\n  FEN += passantSquare ? (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertLocationToNotation)(passantSquare[0], passantSquare[1]) : \"-\";\n  FEN += \" \".concat(game.fiftyMoveRule, \" \").concat(Math.floor((game[\"export\"].length - 1) / 2) + 1);\n  return FEN;\n}\nfunction playSound(game) {\n  if (game.lastMoveSound) {\n    var sound = new Audio(sounds[game.lastMoveSound]);\n    sound.play();\n  }\n}\nfunction renderBoard(game) {\n  var whiteSide = game.showingWhiteSide;\n  var boardDiv = game.div.firstChild;\n  var history = game.timeline;\n  boardDiv.innerHTML = \"\";\n  if (boardDiv.parentNode.querySelector('#svg-canvas')) {\n    boardDiv.parentNode.querySelector('#svg-canvas').remove();\n  }\n  var board = whiteSide ? _toConsumableArray(game.board).reverse() : game.board;\n  var increment = whiteSide ? -1 : 1;\n  var highlighted = game.lastMove !== null;\n  var darkSquare = true;\n  var x = whiteSide ? 7 : 0;\n  var canvas = (0,_marking_js__WEBPACK_IMPORTED_MODULE_3__.createSVGCanvas)(boardDiv);\n  board.forEach(function (row) {\n    var y = whiteSide ? 7 : 0;\n    var newRow = whiteSide ? _toConsumableArray(row).reverse() : row;\n    newRow.forEach(function (square) {\n      var div = document.createElement('div');\n      var notation = (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertLocationToNotation)(x, y);\n      div.setAttribute(\"notation\", notation);\n      div.classList.add(\"square\");\n      (0,_marking_js__WEBPACK_IMPORTED_MODULE_3__.addUserMarkings)(div, game, canvas);\n      darkSquare = !darkSquare;\n      if (darkSquare) {\n        div.classList.add('dark');\n      }\n      var pieceSvg = square ? square.svg : false;\n      if (pieceSvg) {\n        var svg = document.createElement('img');\n        svg.src = pieceSvg;\n        if (history === 0 && !game.result) {\n          if (game.playerIsWhite !== null && square.isWhite === game.playerIsWhite && game.playerIsWhite === game.whitesMove) {\n            (0,_drag_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(square, svg, renderBoard);\n          }\n        }\n        div.appendChild(svg);\n      }\n      boardDiv.appendChild(div);\n      y += increment;\n    });\n    darkSquare = !darkSquare;\n    x += increment;\n  });\n  var checkLocation = (0,_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__.inCheck)(game);\n  if (checkLocation) {\n    boardDiv.querySelector(\"[notation=\".concat(checkLocation, \"]\")).classList.add(\"check\");\n  }\n  if (highlighted) {\n    boardDiv.querySelector(\"[notation=\".concat(game.lastMove[0])).classList.add(\"highlighted\");\n    boardDiv.querySelector(\"[notation=\".concat(game.lastMove[1])).classList.add(\"highlighted\");\n  }\n  if (game.result) {\n    (0,_game_main_js__WEBPACK_IMPORTED_MODULE_10__.updateToast)(game.result);\n  }\n  (0,_marking_js__WEBPACK_IMPORTED_MODULE_3__.drawUserMarkings)(game, canvas);\n  (0,_marking_js__WEBPACK_IMPORTED_MODULE_3__.annotateBoard)(boardDiv, whiteSide);\n  (0,_marking_js__WEBPACK_IMPORTED_MODULE_3__.markHoveredPieces)(boardDiv);\n  return boardDiv;\n}\nfunction waitForMove(_x) {\n  return _waitForMove.apply(this, arguments);\n}\nfunction _waitForMove() {\n  _waitForMove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(game) {\n    var move;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return (0,_game_random_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(game, !game.playerIsWhite);\n        case 2:\n          move = _context.sent;\n          if (move) {\n            game.board[move[0][0]][move[0][1]].move(move[1][0], move[1][1]);\n            postMove(game, false, game.socket);\n            (0,_modify_js__WEBPACK_IMPORTED_MODULE_9__.undoMove)(game, false);\n          } else {\n            console.log(\"no moves left\");\n          }\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _waitForMove.apply(this, arguments);\n}\nfunction fetchMove(game, UCI) {\n  var sound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var ignoreGameOver = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var ignoreLegality = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var startSquare = (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertNotationtoLocation)(UCI.substring(0, 2).toLowerCase());\n  var endSquare = (0,_notation_js__WEBPACK_IMPORTED_MODULE_1__.convertNotationtoLocation)(UCI.substring(2, 4).toLowerCase());\n  var promotion = UCI.substring(4, 5);\n  var pieces = {\n    \"q\": \"queen\",\n    \"r\": \"rook\",\n    \"n\": \"knight\",\n    \"b\": \"bishop\"\n  };\n  var promotionPiece = promotion ? pieces[promotion.toLowerCase()] : false;\n  if (ignoreLegality) {\n    game.board[startSquare[0]][startSquare[1]].move(endSquare[0], endSquare[1], promotionPiece, false, true);\n    return game;\n  }\n  if ((0,_animations_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(game, startSquare[0], startSquare[1], endSquare[0], endSquare[1], sound, promotionPiece)) {\n    game[\"export\"].push(UCI);\n    if (!ignoreGameOver) {\n      var end = (0,_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__.gameOver)(game);\n      if (end) {\n        game.result = {\n          result: end.result,\n          reason: end.reason\n        };\n      }\n    }\n    return game;\n  } else {\n    throw new Error(\"Could not complete move.\");\n  }\n}\nfunction postMove(game, promotion, socket) {\n  var UCI = game.lastMove.join('').concat(promotion ? promotion[0] : \"\");\n  if (socket) {\n    if (socket.readyState === 3) {\n      (0,_modify_js__WEBPACK_IMPORTED_MODULE_9__.undoMove)(game, false);\n      (0,_game_main_js__WEBPACK_IMPORTED_MODULE_10__.updateToast)(\"Not connected to the game. Try refreshing?\");\n      return;\n    }\n    socket.send(JSON.stringify({\n      uci: UCI,\n      id: game.id,\n      token: localStorage.getItem('token')\n    }));\n    if (game.timer) {\n      game.timer.alternate();\n    }\n  }\n  var end = (0,_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__.gameOver)(game);\n  if (end) {\n    game.result = {\n      result: end.result,\n      reason: end.reason\n    };\n  }\n  game[\"export\"].push(UCI);\n  return UCI;\n}\nfunction animateGame(game, moves, sound) {\n  var msspeed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n  var interval = setInterval(function () {\n    if (moves.length === 0) {\n      clearInterval(interval);\n      return;\n    }\n    var move = moves.shift();\n    fetchMove(game, move, sound);\n  }, msspeed);\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve();\n    }, msspeed * (moves.length + 2));\n  });\n}\nfunction createGame(fen) {\n  var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var boardContainer = document.createElement('div');\n  var boardDiv = document.createElement('div');\n  boardContainer.id = \"board-container\";\n  boardDiv.id = \"board\";\n  boardContainer.appendChild(boardDiv);\n  boardContainer.oncontextmenu = function () {\n    return false;\n  };\n  if (!fen) {\n    fen = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n  }\n  var chessGame = FENtoBoard(fen);\n  chessGame.div = boardContainer;\n  if (render) {\n    renderBoard(chessGame);\n  }\n  return chessGame;\n}\n\n// Example input: [\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\", [\"d2d4\", \"d7d5\"]] \n\nfunction importGame(fenUCIexport) {\n  var chessGame = createGame(fenUCIexport[0], true);\n  if (fenUCIexport.length > 1) {\n    fenUCIexport.slice(1).forEach(function (arr) {\n      arr.forEach(function (move) {\n        if (move === \"\") {\n          return;\n        }\n        fetchMove(chessGame, move, false, true, true);\n      });\n    });\n  }\n  chessGame.result = (0,_pieces_piece_js__WEBPACK_IMPORTED_MODULE_0__.gameOver)(chessGame);\n  renderBoard(chessGame);\n  return chessGame;\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/board.js?");

/***/ }),

/***/ "./src/chess/drag.js":
/*!***************************!*\
  !*** ./src/chess/drag.js ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ makeDraggable)\n/* harmony export */ });\n/* harmony import */ var _notation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./notation */ \"./src/chess/notation.js\");\n/* harmony import */ var _animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animations */ \"./src/chess/animations.js\");\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./board */ \"./src/chess/board.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_animations__WEBPACK_IMPORTED_MODULE_1__, _board__WEBPACK_IMPORTED_MODULE_2__]);\n([_animations__WEBPACK_IMPORTED_MODULE_1__, _board__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nfunction makeDraggable(square, svg, renderBoard) {\n  svg.addEventListener('mousedown', function (e) {\n    if (svg.parentNode.classList.contains('possiblepiece')) {\n      return;\n    }\n    e.preventDefault();\n    var alreadyHighlighted = svg.parentNode.classList.contains(\"highlighted\");\n    var board = square.game.div.firstChild;\n    if (e.buttons === 1) {\n      // render board and set svg (since svg changes when you render board) so it resets users selection if there is one\n      board = renderBoard(square.game);\n      svg = board.querySelector(\"[notation=\".concat((0,_notation__WEBPACK_IMPORTED_MODULE_0__.convertLocationToNotation)(square.xPos, square.yPos))).lastChild;\n    }\n    var moves = square.moves();\n    var legalSquares = movesToDivs(moves, board);\n    var allSquares = board.querySelectorAll('.square');\n    var initialSquare = svg.parentNode;\n    var size;\n    var outsideInitialSquare = false;\n    if (e.buttons === 1) {\n      var canvas = svg.parentNode.parentNode.parentNode.querySelector(\"#svg-canvas\");\n      canvas.innerHTML = \"\";\n      square.game.drawnArrows = [];\n      square.game.userHighlights = [];\n      // Set size here everytime in case user resizes window\n      size = svg.parentNode.parentNode.offsetWidth / 8;\n      // We declare the event listeners here to the document \n      // because pointer-events: none unbinds the svg event listeners\n      document.addEventListener('mousedown', mouseDown);\n      document.addEventListener('mousemove', mouseMove);\n      document.addEventListener('mouseup', mouseUp);\n      allSquares.forEach(function (div) {\n        if (legalSquares.includes(div)) {\n          if (div.querySelector('img')) {\n            div.classList.add(\"possiblepiece\");\n          } else {\n            div.classList.add(\"possible\");\n          }\n          div.addEventListener('click', click);\n        } else {\n          div.addEventListener('click', clear);\n        }\n      });\n      moveToCursor(e, svg, size);\n    }\n    // Clears user selection if they click off a valid move\n    function clear(event) {\n      event.preventDefault();\n      document.removeEventListener('mousedown', mouseDown);\n      document.removeEventListener('mouseup', mouseUp);\n      document.removeEventListener('mousemove', mouseMove);\n      document.removeEventListener('click', clear);\n      allSquares.forEach(function (div) {\n        div.removeEventListener('click', click);\n        div.removeEventListener('click', clear);\n      });\n      renderBoard(square.game);\n    }\n    function mouseDown(event) {\n      // This is done so users can cancel their moves with any button\n      event.preventDefault();\n      if (event.buttons !== 1) {\n        document.removeEventListener('mouseup', mouseUp);\n        document.removeEventListener('mousemove', mouseMove);\n        document.removeEventListener('click', clear);\n        document.removeEventListener('mousedown', mouseDown);\n        renderBoard(square.game);\n      }\n    }\n    function mouseMove(event) {\n      if (board.querySelector(\"#board .square.select\") !== initialSquare) {\n        outsideInitialSquare = true;\n      }\n      moveToCursor(event, svg, size);\n    }\n    function mouseUp(event) {\n      event.preventDefault();\n      document.removeEventListener('mousedown', mouseDown);\n      document.removeEventListener('mouseup', mouseUp);\n      document.removeEventListener('mousemove', mouseMove);\n      svg.style.pointerEvents = \"auto\";\n      var move = selectSquare(board);\n      if (event.buttons === 0 && square.move(move[0], move[1], false, true)) {\n        (0,_board__WEBPACK_IMPORTED_MODULE_2__.playSound)(square.game);\n        renderBoard(square.game);\n        //setTimeout(() => {\n        //    waitForMove(square.game)\n        //}, 100);\n      }\n\n      if (!outsideInitialSquare) {\n        svg.style.position = null;\n        svg.style.zIndex = \"1\";\n        if (alreadyHighlighted) {\n          clear(e);\n        }\n      } else {\n        clear(e);\n      }\n    }\n    function click(event) {\n      event.preventDefault();\n      var move = (0,_notation__WEBPACK_IMPORTED_MODULE_0__.convertNotationtoLocation)(event.target.getAttribute(\"notation\") || event.target.parentNode.getAttribute(\"notation\"));\n      var originalPos = [square.xPos, square.yPos];\n      // Remove indicators as they're no longer relevant\n      board.querySelectorAll('.possible').forEach(function (square) {\n        square.classList.remove('possible');\n      });\n      board.querySelectorAll('.possiblepiece').forEach(function (square) {\n        square.classList.remove('possiblepiece');\n      });\n      (0,_animations__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(square.game, originalPos[0], originalPos[1], move[0], move[1], false, false, true);\n      (0,_board__WEBPACK_IMPORTED_MODULE_2__.playSound)(square.game);\n      //setTimeout(() => {\n      //    waitForMove(square.game)\n      //}, 100);\n      document.removeEventListener('mousedown', mouseDown);\n      document.removeEventListener('mouseup', mouseUp);\n      document.removeEventListener('mousemove', mouseMove);\n      document.removeEventListener('click', clear);\n      allSquares.forEach(function (div) {\n        div.removeEventListener('click', click);\n        div.removeEventListener('click', clear);\n      });\n    }\n  });\n}\nfunction moveToCursor(event, svg, size) {\n  var x = event.clientX - size / 2;\n  var y = event.clientY - size / 2;\n\n  // Using fixed style here instead of transform because \n  // transform did not work for some users\n  svg.style.pointerEvents = \"none\";\n  svg.style.zIndex = \"2\";\n  svg.style.position = \"fixed\";\n  svg.style.width = \"\".concat(size, \"px\");\n  svg.style.height = \"\".concat(size, \"px\");\n  svg.style.left = \"\".concat(x, \"px\");\n  svg.style.top = \"\".concat(y, \"px\");\n  svg.parentNode.classList.add('highlighted');\n}\nfunction selectSquare(board) {\n  var notation = board.querySelector(\".square.select\");\n  return notation ? (0,_notation__WEBPACK_IMPORTED_MODULE_0__.convertNotationtoLocation)(notation.getAttribute(\"notation\")) : false;\n}\nfunction movesToDivs(moves, board) {\n  var divs = [];\n  moves.forEach(function (move) {\n    var square = (0,_notation__WEBPACK_IMPORTED_MODULE_0__.convertLocationToNotation)(move[0], move[1]);\n    var squareDiv = board.querySelector(\"[notation=\".concat(square));\n    divs.push(squareDiv);\n  });\n  return divs;\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/drag.js?");

/***/ }),

/***/ "./src/chess/marking.js":
/*!******************************!*\
  !*** ./src/chess/marking.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUserMarkings: () => (/* binding */ addUserMarkings),\n/* harmony export */   annotateBoard: () => (/* binding */ annotateBoard),\n/* harmony export */   createSVGCanvas: () => (/* binding */ createSVGCanvas),\n/* harmony export */   drawArrow: () => (/* binding */ drawArrow),\n/* harmony export */   drawUserMarkings: () => (/* binding */ drawUserMarkings),\n/* harmony export */   markHoveredPieces: () => (/* binding */ markHoveredPieces)\n/* harmony export */ });\nfunction createSVGCanvas(boardDiv) {\n  var arrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  arrowSvg.id = \"svg-canvas\";\n  arrowSvg.setAttribute('height', boardDiv.offsetHeight);\n  arrowSvg.setAttribute('width', boardDiv.offsetWidth);\n  arrowSvg.setAttribute('viewBox', \"0 0 \".concat(boardDiv.offsetWidth, \" \").concat(boardDiv.offsetHeight));\n  boardDiv.parentNode.appendChild(arrowSvg);\n  return arrowSvg;\n}\nfunction markHoveredPieces(boardDiv) {\n  var boardSquares = boardDiv.querySelectorAll(\"#board .square\");\n  boardSquares.forEach(function (square) {\n    square.addEventListener(\"mouseover\", function () {\n      square.classList.add(\"select\");\n    });\n    square.addEventListener(\"mouseout\", function () {\n      square.classList.remove(\"select\");\n    });\n  });\n}\n\n// Modified version of https://github.com/frogcat/canvas-arrow\nfunction drawArrow(fromX, fromY, toX, toY, canvas) {\n  var skinny = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var size = canvas.viewBox.baseVal.width;\n  var width = size / 80 * (skinny ? 0.75 : 1);\n  var arrowHeadWidth = size / 32 * (skinny ? 0.75 : 1);\n  var arrowHeadHeight = size / -21.5 * (skinny ? 0.75 : 1);\n  var offset = size / 21;\n  var dx = toX - fromX;\n  var dy = toY - fromY;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var sin = dy / len;\n  var cos = dx / len;\n  fromX += offset * cos;\n  fromY += offset * sin;\n  toX -= skinny ? cos * 11 : cos;\n  toY -= skinny ? sin * 11 : cos;\n  dx = toX - fromX;\n  dy = toY - fromY;\n  len = Math.sqrt(dx * dx + dy * dy);\n  var controlPoints = [0, width, arrowHeadHeight, width, arrowHeadHeight, arrowHeadWidth];\n  var a = [];\n  a.push(0, 0);\n  for (var i = 0; i < controlPoints.length; i += 2) {\n    var x = controlPoints[i];\n    var y = controlPoints[i + 1];\n    a.push(x < 0 ? len + x : x, y);\n  }\n  a.push(len, 0);\n  for (var _i = controlPoints.length; _i > 0; _i -= 2) {\n    var _x = controlPoints[_i - 2];\n    var _y = controlPoints[_i - 1];\n    a.push(_x < 0 ? len + _x : _x, -_y);\n  }\n  a.push(0, 0);\n  var points = '';\n  for (var _i2 = 0; _i2 < a.length; _i2 += 2) {\n    var _x2 = a[_i2] * cos - a[_i2 + 1] * sin + fromX;\n    var _y2 = a[_i2] * sin + a[_i2 + 1] * cos + fromY;\n    points += \"\".concat(_x2, \",\").concat(_y2, \" \");\n  }\n  var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n  polygon.setAttribute('points', points);\n  polygon.setAttribute('fill', 'orange');\n  polygon.setAttribute('opacity', '0.65');\n  canvas.appendChild(polygon);\n}\nfunction drawUserHighlights(game) {\n  game.div.querySelectorAll('.userHighlight').forEach(function (div) {\n    div.classList.remove(\"userHighlight\");\n  });\n  game.userHighlights.forEach(function (div) {\n    var square = game.div.querySelector(\"[notation=\".concat(div));\n    square.classList.add(\"userHighlight\");\n  });\n}\nfunction drawArrows(game, canvas) {\n  game.drawnArrows.forEach(function (arrow) {\n    var initialSquare = game.div.querySelector(\"[notation=\".concat(arrow[0]));\n    var destinationSquare = game.div.querySelector(\"[notation=\".concat(arrow[1]));\n    var width = initialSquare.offsetWidth;\n    var fromCenterX = initialSquare.offsetLeft + width / 2;\n    var fromCenterY = initialSquare.offsetTop + width / 2;\n    var toCenterX = destinationSquare.offsetLeft + width / 2;\n    var toCenterY = destinationSquare.offsetTop + width / 2;\n    drawArrow(fromCenterX, fromCenterY, toCenterX, toCenterY, canvas);\n  });\n}\nfunction drawUserMarkings(game, canvas) {\n  drawUserHighlights(game);\n  drawArrows(game, canvas);\n}\nfunction addUserMarkings(squareDiv, game, canvas) {\n  var fromCenterX;\n  var fromCenterY;\n  var toCenterX;\n  var toCenterY;\n  squareDiv.addEventListener('mousedown', function (e) {\n    var squareDivNot = squareDiv.getAttribute('notation');\n    var board;\n    var width;\n    if (e.buttons == 2) {\n      var boardContainer = game.div;\n      // This was the best way I could think of to work around board rendering and having a piece selected\n      boardContainer.querySelector('.square:not(.possible):not(.possiblepiece)').click();\n      squareDiv = boardContainer.querySelector(\"[notation=\".concat(squareDivNot, \"]\"));\n      canvas = boardContainer.querySelector(\"#svg-canvas\");\n      board = squareDiv.parentNode;\n      width = squareDiv.offsetWidth;\n      if (canvas.viewBox.baseVal.width !== board.offsetWidth) {\n        canvas.setAttribute('viewBox', \"0 0 \".concat(board.offsetWidth, \" \").concat(board.offsetWidth));\n      }\n      fromCenterX = squareDiv.offsetLeft + width / 2;\n      fromCenterY = squareDiv.offsetTop + width / 2;\n      toCenterX = fromCenterX;\n      toCenterY = fromCenterY;\n      document.addEventListener('mousemove', drawPreviewArrow);\n      document.addEventListener('mouseup', finalizeInput);\n    } else {\n      if (squareDiv.parentNode) {\n        squareDiv.parentNode.querySelectorAll(\".square\").forEach(function (div) {\n          div.classList.remove(\"userHighlight\");\n        });\n        game.drawnArrows = [];\n        game.userHighlights = [];\n        canvas.innerHTML = \"\";\n        document.removeEventListener('mousemove', drawPreviewArrow);\n        document.removeEventListener('mouseup', finalizeInput);\n      }\n    }\n    function drawPreviewArrow(event) {\n      canvas.innerHTML = \"\";\n      var hoveredSquare = board.querySelector('.square.select');\n      if (hoveredSquare) {\n        toCenterX = hoveredSquare.offsetLeft + width / 2 || fromCenterX;\n        toCenterY = hoveredSquare.offsetTop + width / 2 || fromCenterY;\n        drawArrow(fromCenterX, fromCenterY, toCenterX, toCenterY, canvas, true);\n      }\n      drawArrows(game, canvas);\n    }\n    function finalizeInput(event) {\n      document.removeEventListener('mousemove', drawPreviewArrow);\n      document.removeEventListener('mouseup', finalizeInput);\n      if (squareDiv.parentNode && event.button === 2) {\n        var initialSquare = squareDiv;\n        var destinationSquare = squareDiv.parentNode.querySelector('.square.select');\n        if (destinationSquare && initialSquare === destinationSquare) {\n          var position = initialSquare.getAttribute(\"notation\");\n          var index = game.userHighlights.indexOf(position);\n          index === -1 ? game.userHighlights.push(position) : game.userHighlights.splice(index, 1);\n          drawUserHighlights(game);\n        } else {\n          if (destinationSquare) {\n            var fromDiv = initialSquare.getAttribute(\"notation\");\n            var toDiv = destinationSquare.getAttribute(\"notation\");\n            var _position = [fromDiv, toDiv];\n            var _index = false;\n            game.drawnArrows.forEach(function (arrow, i) {\n              if (arrow.every(function (value, i) {\n                return value === _position[i];\n              })) {\n                _index = i;\n              }\n            });\n            _index || _index === 0 ? game.drawnArrows.splice(_index, 1) : game.drawnArrows.push(_position);\n            canvas.innerHTML = \"\";\n            drawArrows(game, canvas);\n          }\n        }\n      }\n    }\n  });\n}\nfunction annotateBoard(boardDiv, whiteSide) {\n  var alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"];\n  var leftNotation = whiteSide ? \"a\" : \"h\";\n  var bottomNotation = whiteSide ? 1 : 8;\n  var darkSquare = !whiteSide;\n  for (var i = 1; i <= 8; i++) {\n    var leftDiv = boardDiv.querySelector(\"[notation=\".concat(leftNotation + i, \"]\"));\n    var notation = document.createElement('span');\n    notation.classList.add('left-notation');\n    notation.classList.add(darkSquare ? 'dark' : 'light');\n    notation.innerHTML = i;\n    leftDiv.prepend(notation);\n    darkSquare = !darkSquare;\n  }\n  for (var letter in alphabet) {\n    var bottomDiv = boardDiv.querySelector(\"[notation=\".concat(alphabet[letter] + bottomNotation, \"]\"));\n    var _notation = document.createElement('span');\n    _notation.classList.add('bottom-notation');\n    _notation.classList.add(darkSquare ? 'dark' : 'light');\n    _notation.innerHTML = alphabet[letter];\n    bottomDiv.prepend(_notation);\n    darkSquare = !darkSquare;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/marking.js?");

/***/ }),

/***/ "./src/chess/modify.js":
/*!*****************************!*\
  !*** ./src/chess/modify.js ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changePlayerSide: () => (/* binding */ changePlayerSide),\n/* harmony export */   flipBoard: () => (/* binding */ flipBoard),\n/* harmony export */   undoMove: () => (/* binding */ undoMove),\n/* harmony export */   viewBackHistory: () => (/* binding */ viewBackHistory),\n/* harmony export */   viewCurrentGame: () => (/* binding */ viewCurrentGame),\n/* harmony export */   viewForwardHistory: () => (/* binding */ viewForwardHistory),\n/* harmony export */   viewStartHistory: () => (/* binding */ viewStartHistory)\n/* harmony export */ });\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/chess/board.js\");\n/* harmony import */ var _pieces_piece__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieces/piece */ \"./src/chess/pieces/piece.js\");\n/* harmony import */ var _animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animations */ \"./src/chess/animations.js\");\n/* harmony import */ var _notation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notation */ \"./src/chess/notation.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_board__WEBPACK_IMPORTED_MODULE_0__, _pieces_piece__WEBPACK_IMPORTED_MODULE_1__, _animations__WEBPACK_IMPORTED_MODULE_2__]);\n([_board__WEBPACK_IMPORTED_MODULE_0__, _pieces_piece__WEBPACK_IMPORTED_MODULE_1__, _animations__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n\n\nfunction viewBackHistory(game) {\n  var length = game.history.length;\n  var prevHistory = game.timeline;\n  if (game.timeline < length) {\n    game.timeline++;\n  }\n  if (game.timeline === 1) {\n    var loc = (0,_notation__WEBPACK_IMPORTED_MODULE_3__.convertNotationtoLocation)(game.lastMove[1]);\n    var lastPieceMoved = game.board[loc[0]][loc[1]].name;\n    if (lastPieceMoved === \"pawn\" && (loc[0] === 0 || loc[0] === 7)) {\n      undoMove(game);\n      game.div.querySelector('.promotion').remove();\n    } else {\n      (0,_animations__WEBPACK_IMPORTED_MODULE_2__.animateHistory)(game, prevHistory);\n    }\n    return;\n  }\n  (0,_animations__WEBPACK_IMPORTED_MODULE_2__.animateHistory)(game, prevHistory);\n}\nfunction viewForwardHistory(game) {\n  var prevHistory = game.timeline;\n  if (game.timeline > 0) {\n    game.timeline--;\n  }\n  (0,_animations__WEBPACK_IMPORTED_MODULE_2__.animateHistory)(game, prevHistory);\n}\nfunction viewStartHistory(game) {\n  var prevHistory = game.timeline;\n  var length = game.history.length;\n  game.timeline = length;\n  (0,_animations__WEBPACK_IMPORTED_MODULE_2__.animateHistory)(game, prevHistory);\n}\nfunction viewCurrentGame(game) {\n  var prevHistory = game.timeline;\n  game.timeline = 0;\n  (0,_animations__WEBPACK_IMPORTED_MODULE_2__.animateHistory)(game, prevHistory);\n}\nfunction flipBoard(game) {\n  game.showingWhiteSide = !game.showingWhiteSide;\n  if (game.timeline !== 0) {\n    game.history[game.history.length - game.timeline].showingWhiteSide = game.showingWhiteSide;\n    (0,_board__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game.history[game.history.length - game.timeline]);\n  } else {\n    (0,_board__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n  }\n  var whiteInfo = document.querySelector('#whiteInfo');\n  var blackInfo = document.querySelector('#blackInfo');\n  if (whiteInfo && blackInfo) {\n    swap(whiteInfo, blackInfo);\n  }\n}\n\n// https://stackoverflow.com/a/69658357\nfunction swap(a, b) {\n  var dummy = document.createElement(\"span\");\n  a.before(dummy);\n  b.before(a);\n  dummy.replaceWith(b);\n}\nfunction undoMove(game) {\n  var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (game.history.length < 1) {\n    return false;\n  }\n  var animation = game.lastMove;\n  if (render) {\n    (0,_board__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n  }\n  var oldBoard = (0,_pieces_piece__WEBPACK_IMPORTED_MODULE_1__.cloneBoard)(game.history[game.history.length - 1].board);\n  game.board = _toConsumableArray(Array(8)).map(function (e) {\n    return Array(8).fill(null);\n  });\n  // We clone the board and create pieces because squares are binded to specific boards\n  oldBoard.forEach(function (row, x) {\n    row.forEach(function (square, y) {\n      if (square) {\n        (0,_pieces_piece__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(oldBoard[x][y].name, oldBoard[x][y].isWhite, x, y, game);\n      }\n    });\n  });\n  var oldGame = game.history[game.history.length - 1];\n  var properties = ['whiteState', 'blackState', 'lastMove', 'fiftyMoveRule', 'whiteUserSpan', 'blackUserSpan', 'lastMoveSound', 'whitesMove', 'drawnArrows', 'userHighlights', 'showingWhiteSide'];\n  properties.forEach(function (prop) {\n    game[prop] = oldGame[prop];\n  });\n  game.timeline = 0;\n  if (game.history.length > 1) {\n    game.history.pop();\n    game[\"export\"].pop();\n  }\n  if (animation && render) {\n    (0,_animations__WEBPACK_IMPORTED_MODULE_2__.animatePiece)(animation[1], animation[0], game.div.firstChild).then(function () {\n      (0,_board__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n    });\n  } else {\n    if (render) {\n      (0,_board__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n    }\n  }\n  return game;\n}\nfunction changePlayerSide(game, spectator) {\n  game.playerIsWhite = !game.playerIsWhite;\n  if (spectator) {\n    game.playerIsWhite = null;\n  }\n  (0,_board__WEBPACK_IMPORTED_MODULE_0__.renderBoard)(game);\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/modify.js?");

/***/ }),

/***/ "./src/chess/notation.js":
/*!*******************************!*\
  !*** ./src/chess/notation.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLocationToNotation: () => (/* binding */ convertLocationToNotation),\n/* harmony export */   convertNotationtoLocation: () => (/* binding */ convertNotationtoLocation),\n/* harmony export */   lastMoveToNotation: () => (/* binding */ lastMoveToNotation)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction convertLocationToNotation(xPos, yPos) {\n  var file = {\n    0: \"h\",\n    1: \"g\",\n    2: \"f\",\n    3: \"e\",\n    4: \"d\",\n    5: \"c\",\n    6: \"b\",\n    7: \"a\"\n  };\n  return \"\".concat(file[yPos]).concat(xPos + 1);\n}\nfunction convertNotationtoLocation(notation) {\n  var file = {\n    \"h\": 0,\n    \"g\": 1,\n    \"f\": 2,\n    \"e\": 3,\n    \"d\": 4,\n    \"c\": 5,\n    \"b\": 6,\n    \"a\": 7\n  };\n  return [Number(notation[1].toLowerCase()) - 1, file[notation[0]]];\n}\nfunction lastMoveToNotation(game, prevBoard) {\n  var initialSq = game.lastMove[0];\n  var finalSq = game.lastMove[1];\n  var ixy = convertNotationtoLocation(initialSq);\n  var fxy = convertNotationtoLocation(finalSq);\n  var prevPiece = prevBoard[ixy[0]][ixy[1]].name;\n  var finalPiece = game.board[fxy[0]][fxy[1]].name;\n  var take = prevBoard[fxy[0]][fxy[1]] !== null ? \"x\" : \"\";\n  var check = wasCheckOrMate(game, prevBoard);\n  var contextSquare = checkRowsAndColumns(game, prevBoard, initialSq, finalSq, finalPiece);\n  var promotion = prevPiece !== finalPiece;\n  var specialCase = wasSpecialCase(initialSq, finalSq, prevPiece, finalPiece, take, check, promotion);\n  if (specialCase) {\n    return specialCase;\n  }\n  var charPiece = finalPiece === \"knight\" ? \"N\" : finalPiece[0].toUpperCase();\n  return \"\".concat(charPiece).concat(contextSquare).concat(take).concat(finalSq).concat(check);\n}\nfunction checkRowsAndColumns(game, prevBoard, initialSq, finalSq, finalPiece) {\n  var oldBoard = prevBoard;\n  var xy = convertNotationtoLocation(initialSq);\n  var initX = xy[0];\n  var initY = xy[1];\n  xy = convertNotationtoLocation(finalSq);\n  var finalX = xy[0];\n  var finalY = xy[1];\n  var isWhite = game.board[finalX][finalY].isWhite;\n  var columnFlag = false;\n  var rowFlag = false;\n  for (var i = 0; i < 8; i++) {\n    if (oldBoard[initX][i] && oldBoard[initX][i].isWhite === isWhite && oldBoard[initX][i].name === finalPiece && i !== initY) {\n      if (stdMovesHasSquare(game.board[initX][i].standardMoves(), finalX, finalY)) {\n        columnFlag = true;\n      }\n    }\n    if (oldBoard[i][initY] && oldBoard[i][initY].isWhite === isWhite && oldBoard[i][initY].name === finalPiece && i !== initX) {\n      if (stdMovesHasSquare(game.board[i][initY].standardMoves(), finalX, finalY)) {\n        rowFlag = true;\n        break;\n      }\n    }\n  }\n  return \"\".concat(columnFlag ? initialSq[0] : \"\").concat(rowFlag ? initialSq[1] : \"\");\n}\nfunction stdMovesHasSquare(stdMoves, finalX, finalY) {\n  var _iterator = _createForOfIteratorHelper(stdMoves),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var move = _step.value;\n      if (move[0] === finalX && move[1] === finalY) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return false;\n}\nfunction wasSpecialCase(initialSq, finalSq, prevPiece, finalPiece, take, check) {\n  if (wasCastle(finalPiece, initialSq, finalSq)) {\n    return wasCastle(finalPiece, initialSq, finalSq) + check;\n  }\n  if (finalPiece === \"pawn\") {\n    return take ? \"\".concat(initialSq[0], \"x\").concat(finalSq).concat(check) : \"\".concat(finalSq).concat(check);\n  }\n  if (prevPiece !== finalPiece) {\n    if (take) {\n      return \"\".concat(prevPiece[0], \"x\").concat(finalSq).concat(check);\n    } else {\n      return finalSq + check;\n    }\n  }\n}\nfunction wasCastle(finalPiece, initialSq, finalSq) {\n  if (finalPiece === \"king\" && initialSq[0] === \"e\") {\n    if (finalSq[0] === \"g\") {\n      return \"O-O\";\n    }\n    if (finalSq[0] === \"c\") {\n      return \"O-O-O\";\n    }\n  }\n  return false;\n}\nfunction wasCheckOrMate(game, prevBoard) {\n  if (game.lastMoveSound === \"check\") {\n    if (!game.result) {\n      return \"+\";\n    }\n    if (game.result.reason === \"Checkmate\" && compareBoards(game.history[game.history.length - 1].board, prevBoard)) {\n      return \"#\";\n    }\n  }\n  return \"\";\n}\nfunction compareBoards(board1, board2) {\n  for (var i = 0; i < 8; i++) {\n    for (var j = 0; j < 8; j++) {\n      if (board1[i][j] && !board2[i][j]) {\n        return false;\n      }\n      if (!board1[i][j] && board2[i][j]) {\n        return false;\n      }\n      if (board1[i][j] !== board2[i][j]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/notation.js?");

/***/ }),

/***/ "./src/chess/pieces/bishop.js":
/*!************************************!*\
  !*** ./src/chess/pieces/bishop.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Bishop)\n/* harmony export */ });\n/* harmony import */ var _piece_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece.js */ \"./src/chess/pieces/piece.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_piece_js__WEBPACK_IMPORTED_MODULE_0__]);\n_piece_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Bishop(_ref) {\n  var isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    game = _ref.game;\n  var piece = (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.Piece)({\n    name: \"bishop\",\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game,\n    standardMoves: function standardMoves() {\n      var directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];\n      var moves = [];\n      for (var _i = 0, _directions = directions; _i < _directions.length; _i++) {\n        var direction = _directions[_i];\n        var _direction = _slicedToArray(direction, 2),\n          dx = _direction[0],\n          dy = _direction[1];\n        var x = xPos + dx;\n        var y = yPos + dy;\n        while (!(0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.outOfBounds)(x, y)) {\n          if (game.board[x][y] === null || piece.canCapture(game.board[x][y]) || game.board[x][y].name === \"passant\") {\n            moves.push([x, y]);\n            if (piece.canCapture(game.board[x][y]) && game.board[x][y].name !== \"passant\") {\n              break;\n            }\n          } else {\n            break;\n          }\n          x += dx;\n          y += dy;\n        }\n      }\n      return moves;\n    }\n  });\n  return piece;\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/bishop.js?");

/***/ }),

/***/ "./src/chess/pieces/king.js":
/*!**********************************!*\
  !*** ./src/chess/pieces/king.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ King)\n/* harmony export */ });\n/* harmony import */ var _piece_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece.js */ \"./src/chess/pieces/piece.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_piece_js__WEBPACK_IMPORTED_MODULE_0__]);\n_piece_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nfunction King(_ref) {\n  var isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    game = _ref.game;\n  var piece = (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.Piece)({\n    name: \"king\",\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game,\n    standardMoves: function standardMoves() {\n      var moves = [];\n      var canCastle = game.whiteState === undefined ? false : checkCastleLegality(isWhite, game);\n      var castleState = isWhite ? game.whiteState : game.blackState;\n      var kingRow = isWhite ? 0 : 7;\n      for (var i = -1; i <= 1; i++) {\n        var x = i + xPos;\n        for (var j = -1; j <= 1; j++) {\n          var y = j + yPos;\n          if ((0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.outOfBounds)(x, y)) {\n            continue;\n          }\n          if (game.board[x][y] === null || piece.canCapture(game.board[x][y])) {\n            moves.push([x, y, function () {\n              castleState.longCastle = false;\n              castleState.shortCastle = false;\n            }]);\n          }\n        }\n      }\n      if (canCastle) {\n        if (canCastle[\"short\"] && game.board[kingRow][1] === null && game.board[kingRow][2] === null) {\n          moves.push([kingRow, 1, function () {\n            castleState.longCastle = false;\n            castleState.shortCastle = false;\n            game.board[kingRow][0] = null;\n            (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"rook\", isWhite, kingRow, 2, game);\n          }]);\n        }\n        if (canCastle[\"long\"] && game.board[kingRow][4] === null && game.board[kingRow][5] === null && game.board[kingRow][6] === null) {\n          moves.push([kingRow, 5, function () {\n            castleState.longCastle = false;\n            castleState.shortCastle = false;\n            game.board[kingRow][7] = null;\n            (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"rook\", isWhite, kingRow, 4, game);\n          }]);\n        }\n      }\n      return moves;\n    }\n  });\n  piece.inCheck = function () {\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        if (game.board[i][j] && game.board[i][j].standardMoves().some(function (pos) {\n          return pos[0] === xPos && pos[1] === yPos;\n        })) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  return piece;\n}\nfunction checkCastleLegality(isWhite, game) {\n  var castleState = isWhite ? game.whiteState : game.blackState;\n  var kingRow = isWhite ? 0 : 7;\n  if (castleState === undefined || !castleState.shortCastle && !castleState.longCastle) {\n    return false;\n  }\n  // Get all of the moves here instead of isLegal because these don't have to be legal captures\n  var moves = [];\n  var boardClone = (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.cloneBoard)(game.board);\n  for (var i = 0; i < 8; i++) {\n    for (var j = 0; j < 8; j++) {\n      if (game.board[i][j]) {\n        if (game.board[i][j].isWhite === !isWhite) {\n          boardClone[i][j].standardMoves().map(function (move) {\n            return moves.push(move);\n          });\n        }\n        if (game.board[i][j].name === \"king\" && game.board[i][j].isWhite === isWhite) {\n          if (boardClone[i][j].inCheck()) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  var _short = false;\n  var _long = false;\n  if (castleState.shortCastle) {\n    if (!moves.some(function (move) {\n      return move[0] === kingRow && move[1] === 2;\n    }) && !moves.some(function (move) {\n      return move[0] === kingRow && move[1] === 1;\n    })) {\n      _short = true;\n    }\n    if (game.board[kingRow][0].isWhite !== isWhite || game.board[kingRow][0].name !== \"rook\") {\n      castleState.shortCastle = false;\n      _short = false;\n    }\n  }\n  if (castleState.longCastle) {\n    if (!moves.some(function (move) {\n      return move[0] === kingRow && move[1] === 4;\n    }) && !moves.some(function (move) {\n      return move[0] === kingRow && move[1] === 5;\n    })) {\n      _long = true;\n    }\n    if (game.board[kingRow][7].isWhite !== isWhite || game.board[kingRow][7].name !== \"rook\") {\n      castleState.longCastle = false;\n      _long = false;\n    }\n  }\n  return {\n    \"short\": _short,\n    \"long\": _long\n  };\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/king.js?");

/***/ }),

/***/ "./src/chess/pieces/knight.js":
/*!************************************!*\
  !*** ./src/chess/pieces/knight.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Knight)\n/* harmony export */ });\n/* harmony import */ var _piece_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece.js */ \"./src/chess/pieces/piece.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_piece_js__WEBPACK_IMPORTED_MODULE_0__]);\n_piece_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nfunction Knight(_ref) {\n  var isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    game = _ref.game;\n  var piece = (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.Piece)({\n    name: \"knight\",\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game,\n    standardMoves: function standardMoves() {\n      var moves = [];\n      var knightMoves = [[2, 1], [1, 2], [-2, 1], [-1, 2], [2, -1], [1, -2], [-2, -1], [-1, -2]];\n      knightMoves.forEach(function (move) {\n        var x = xPos + move[0];\n        var y = yPos + move[1];\n        if (!(0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.outOfBounds)(x, y) && (game.board[x][y] === null || piece.canCapture(game.board[x][y]))) {\n          moves.push([x, y]);\n        }\n      });\n      return moves;\n    }\n  });\n  return piece;\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/knight.js?");

/***/ }),

/***/ "./src/chess/pieces/pawn.js":
/*!**********************************!*\
  !*** ./src/chess/pieces/pawn.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pawn)\n/* harmony export */ });\n/* harmony import */ var _cburnett_bQ_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cburnett/bQ.svg */ \"./src/chess/cburnett/bQ.svg\");\n/* harmony import */ var _cburnett_wQ_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cburnett/wQ.svg */ \"./src/chess/cburnett/wQ.svg\");\n/* harmony import */ var _cburnett_bR_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cburnett/bR.svg */ \"./src/chess/cburnett/bR.svg\");\n/* harmony import */ var _cburnett_wR_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cburnett/wR.svg */ \"./src/chess/cburnett/wR.svg\");\n/* harmony import */ var _cburnett_bB_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cburnett/bB.svg */ \"./src/chess/cburnett/bB.svg\");\n/* harmony import */ var _cburnett_wB_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cburnett/wB.svg */ \"./src/chess/cburnett/wB.svg\");\n/* harmony import */ var _cburnett_bN_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cburnett/bN.svg */ \"./src/chess/cburnett/bN.svg\");\n/* harmony import */ var _cburnett_wN_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cburnett/wN.svg */ \"./src/chess/cburnett/wN.svg\");\n/* harmony import */ var _piece_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./piece.js */ \"./src/chess/pieces/piece.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_piece_js__WEBPACK_IMPORTED_MODULE_8__]);\n_piece_js__WEBPACK_IMPORTED_MODULE_8__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n\n\nfunction Pawn(_ref) {\n  var isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    game = _ref.game;\n  var piece = (0,_piece_js__WEBPACK_IMPORTED_MODULE_8__.Piece)({\n    name: \"pawn\",\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game,\n    standardMoves: function standardMoves() {\n      var direction = isWhite ? 1 : -1;\n      var starting = isWhite ? xPos === 1 : xPos === 6;\n      var moves = [];\n      var _loop = function _loop() {\n        var x = xPos + direction;\n        var y = yPos + i;\n        if ((0,_piece_js__WEBPACK_IMPORTED_MODULE_8__.outOfBounds)(x, y)) {\n          return \"continue\";\n        }\n        if (i !== 0 && piece.canCapture(game.board[x][y])) {\n          if (game.board[x][y].name === \"passant\") {\n            moves.push([x, y, function () {\n              game.board[x - direction][y] = null;\n            }]);\n            return \"continue\";\n          }\n          if (x === 0 || x === 7) {\n            moves.push([x, y, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var piece;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return promoteMenu(game, isWhite);\n                  case 2:\n                    piece = _context.sent;\n                    return _context.abrupt(\"return\", new Promise(function (resolve) {\n                      resolve(piece);\n                    }));\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }))]);\n            return \"continue\";\n          }\n          moves.push([x, y]);\n        } else if (i === 0 && game.board[xPos + direction][y] == null) {\n          if (starting && game.board[xPos + direction * 2][y] == null) {\n            // add en passant object for this move\n            moves.push([xPos + direction * 2, y, function () {\n              (0,_piece_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(\"passant\", isWhite, xPos + direction, y, game);\n            }]);\n          }\n          if (x === 0 || x === 7) {\n            moves.push([x, y, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n              var piece;\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return promoteMenu(game, isWhite);\n                  case 2:\n                    piece = _context2.sent;\n                    return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                      resolve(piece);\n                    }));\n                  case 4:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }, _callee2);\n            }))]);\n            return \"continue\";\n          }\n          moves.push([x, y]);\n        }\n      };\n      for (var i = -1; i <= 1; i++) {\n        var _ret = _loop();\n        if (_ret === \"continue\") continue;\n      }\n      return moves;\n    }\n  });\n  return piece;\n}\nfunction promoteMenu(_x, _x2) {\n  return _promoteMenu.apply(this, arguments);\n}\nfunction _promoteMenu() {\n  _promoteMenu = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(game, isWhite) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          return _context3.abrupt(\"return\", new Promise(function (resolve) {\n            var boardContainer = game.div;\n            var backdrop = document.createElement(\"div\");\n            var pieces = [[isWhite ? _cburnett_wQ_svg__WEBPACK_IMPORTED_MODULE_1__ : _cburnett_bQ_svg__WEBPACK_IMPORTED_MODULE_0__, \"queen\"], [isWhite ? _cburnett_wN_svg__WEBPACK_IMPORTED_MODULE_7__ : _cburnett_bN_svg__WEBPACK_IMPORTED_MODULE_6__, \"knight\"], [isWhite ? _cburnett_wB_svg__WEBPACK_IMPORTED_MODULE_5__ : _cburnett_bB_svg__WEBPACK_IMPORTED_MODULE_4__, \"bishop\"], [isWhite ? _cburnett_wR_svg__WEBPACK_IMPORTED_MODULE_3__ : _cburnett_bR_svg__WEBPACK_IMPORTED_MODULE_2__, \"rook\"]];\n            backdrop.classList.add(\"promotion\");\n            pieces.forEach(function (piece) {\n              var divParent = document.createElement(\"div\");\n              var img = document.createElement(\"img\");\n              img.src = piece[0];\n              divParent.appendChild(img);\n              divParent.setAttribute(\"value\", piece[1]);\n              divParent.addEventListener(\"click\", function () {\n                var choice = divParent.getAttribute(\"value\");\n                resolve(choice);\n                boardContainer.removeChild(backdrop);\n              });\n              backdrop.appendChild(divParent);\n            });\n            boardContainer.appendChild(backdrop);\n          }));\n        case 1:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _promoteMenu.apply(this, arguments);\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/pawn.js?");

/***/ }),

/***/ "./src/chess/pieces/piece.js":
/*!***********************************!*\
  !*** ./src/chess/pieces/piece.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Piece: () => (/* binding */ Piece),\n/* harmony export */   cloneBoard: () => (/* binding */ cloneBoard),\n/* harmony export */   cloneGame: () => (/* binding */ cloneGame),\n/* harmony export */   \"default\": () => (/* binding */ createPiece),\n/* harmony export */   gameOver: () => (/* binding */ gameOver),\n/* harmony export */   inCheck: () => (/* binding */ inCheck),\n/* harmony export */   outOfBounds: () => (/* binding */ outOfBounds)\n/* harmony export */ });\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../board.js */ \"./src/chess/board.js\");\n/* harmony import */ var _modify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modify.js */ \"./src/chess/modify.js\");\n/* harmony import */ var _notation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../notation.js */ \"./src/chess/notation.js\");\n/* harmony import */ var _king_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./king.js */ \"./src/chess/pieces/king.js\");\n/* harmony import */ var _queen_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./queen.js */ \"./src/chess/pieces/queen.js\");\n/* harmony import */ var _rook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rook.js */ \"./src/chess/pieces/rook.js\");\n/* harmony import */ var _knight_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./knight.js */ \"./src/chess/pieces/knight.js\");\n/* harmony import */ var _bishop_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bishop.js */ \"./src/chess/pieces/bishop.js\");\n/* harmony import */ var _pawn_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pawn.js */ \"./src/chess/pieces/pawn.js\");\n/* harmony import */ var _cburnett_bK_svg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../cburnett/bK.svg */ \"./src/chess/cburnett/bK.svg\");\n/* harmony import */ var _cburnett_wK_svg__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../cburnett/wK.svg */ \"./src/chess/cburnett/wK.svg\");\n/* harmony import */ var _cburnett_bQ_svg__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../cburnett/bQ.svg */ \"./src/chess/cburnett/bQ.svg\");\n/* harmony import */ var _cburnett_wQ_svg__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../cburnett/wQ.svg */ \"./src/chess/cburnett/wQ.svg\");\n/* harmony import */ var _cburnett_bR_svg__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../cburnett/bR.svg */ \"./src/chess/cburnett/bR.svg\");\n/* harmony import */ var _cburnett_wR_svg__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../cburnett/wR.svg */ \"./src/chess/cburnett/wR.svg\");\n/* harmony import */ var _cburnett_bB_svg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../cburnett/bB.svg */ \"./src/chess/cburnett/bB.svg\");\n/* harmony import */ var _cburnett_wB_svg__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../cburnett/wB.svg */ \"./src/chess/cburnett/wB.svg\");\n/* harmony import */ var _cburnett_bN_svg__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../cburnett/bN.svg */ \"./src/chess/cburnett/bN.svg\");\n/* harmony import */ var _cburnett_wN_svg__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../cburnett/wN.svg */ \"./src/chess/cburnett/wN.svg\");\n/* harmony import */ var _cburnett_bP_svg__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../cburnett/bP.svg */ \"./src/chess/cburnett/bP.svg\");\n/* harmony import */ var _cburnett_wP_svg__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../cburnett/wP.svg */ \"./src/chess/cburnett/wP.svg\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_board_js__WEBPACK_IMPORTED_MODULE_1__, _modify_js__WEBPACK_IMPORTED_MODULE_2__, _king_js__WEBPACK_IMPORTED_MODULE_4__, _queen_js__WEBPACK_IMPORTED_MODULE_5__, _rook_js__WEBPACK_IMPORTED_MODULE_6__, _knight_js__WEBPACK_IMPORTED_MODULE_7__, _bishop_js__WEBPACK_IMPORTED_MODULE_8__, _pawn_js__WEBPACK_IMPORTED_MODULE_9__]);\n([_board_js__WEBPACK_IMPORTED_MODULE_1__, _modify_js__WEBPACK_IMPORTED_MODULE_2__, _king_js__WEBPACK_IMPORTED_MODULE_4__, _queen_js__WEBPACK_IMPORTED_MODULE_5__, _rook_js__WEBPACK_IMPORTED_MODULE_6__, _knight_js__WEBPACK_IMPORTED_MODULE_7__, _bishop_js__WEBPACK_IMPORTED_MODULE_8__, _pawn_js__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar blackPieces = {\n  \"pawn\": _cburnett_bP_svg__WEBPACK_IMPORTED_MODULE_20__,\n  \"king\": _cburnett_bK_svg__WEBPACK_IMPORTED_MODULE_10__,\n  \"queen\": _cburnett_bQ_svg__WEBPACK_IMPORTED_MODULE_12__,\n  \"bishop\": _cburnett_bB_svg__WEBPACK_IMPORTED_MODULE_16__,\n  \"knight\": _cburnett_bN_svg__WEBPACK_IMPORTED_MODULE_18__,\n  \"rook\": _cburnett_bR_svg__WEBPACK_IMPORTED_MODULE_14__\n};\nvar whitePieces = {\n  \"pawn\": _cburnett_wP_svg__WEBPACK_IMPORTED_MODULE_21__,\n  \"king\": _cburnett_wK_svg__WEBPACK_IMPORTED_MODULE_11__,\n  \"queen\": _cburnett_wQ_svg__WEBPACK_IMPORTED_MODULE_13__,\n  \"bishop\": _cburnett_wB_svg__WEBPACK_IMPORTED_MODULE_17__,\n  \"knight\": _cburnett_wN_svg__WEBPACK_IMPORTED_MODULE_19__,\n  \"rook\": _cburnett_wR_svg__WEBPACK_IMPORTED_MODULE_15__\n};\nfunction Piece(_ref) {\n  var name = _ref.name,\n    isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    standardMoves = _ref.standardMoves,\n    game = _ref.game;\n  return {\n    name: name,\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    standardMoves: standardMoves,\n    game: game,\n    svg: isWhite ? whitePieces[name] || false : blackPieces[name] || false,\n    canCapture: function canCapture(capturedPiece) {\n      return capturedPiece ? isWhite !== capturedPiece.isWhite : false;\n    },\n    move: function move(toX, toY, promotion) {\n      var post = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var ignoreLegality = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var moves = !ignoreLegality ? standardMoves().filter(function (move) {\n        return isLegal(xPos, yPos, move[0], move[1], isWhite, game.board);\n      }) : standardMoves();\n      if (ignoreLegality || game.whitesMove === isWhite && moves.some(function (pos) {\n        return pos[0] === toX && pos[1] === toY;\n      })) {\n        var index = moves.findIndex(function (pos) {\n          return pos[0] === toX && pos[1] === toY;\n        });\n        game.history.push(cloneGame(game));\n        game.lastMove = [(0,_notation_js__WEBPACK_IMPORTED_MODULE_3__.convertLocationToNotation)(xPos, yPos), (0,_notation_js__WEBPACK_IMPORTED_MODULE_3__.convertLocationToNotation)(toX, toY)];\n        game.lastMoveSound = game.board[toX][toY] === null ? \"place\" : \"capture\";\n        if (game.board[toX][toY] && name !== \"pawn\" && game.board[toX][toY].name === \"passant\") {\n          game.lastMoveSound = \"place\";\n        }\n        if (name === \"pawn\" || game.lastMoveSound === \"capture\") {\n          game.fiftyMoveRule = 0;\n        } else {\n          game.fiftyMoveRule += 1;\n        }\n\n        // Remove any en passant remnants\n        for (var i = 0; i < 8; i++) {\n          if (game.board[2][i] && game.board[2][i].name === \"passant\") {\n            game.board[2][i] = null;\n            break;\n          }\n          if (game.board[5][i] && game.board[5][i].name === \"passant\") {\n            game.board[5][i] = null;\n            break;\n          }\n        }\n\n        // Move piece and change side's move\n        if (promotion) {\n          name = promotion;\n        }\n        createPiece(name, isWhite, toX, toY, game);\n        game.board[xPos][yPos] = null;\n        game.whitesMove = !game.whitesMove;\n\n        // Any additional things you may want a piece to do\n        if (moves[index].length > 2 && !promotion) {\n          var func = moves[index][2]();\n          if (func && func[Symbol.toStringTag] === 'Promise') {\n            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var piece;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return func;\n                  case 2:\n                    piece = _context.sent;\n                    (0,_modify_js__WEBPACK_IMPORTED_MODULE_2__.undoMove)(game, false);\n                    game.board[xPos][yPos].move(toX, toY, piece, true);\n                    return _context.abrupt(\"return\", true);\n                  case 6:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }))();\n          }\n        }\n        if (inCheck(game)) {\n          game.lastMoveSound = \"check\";\n        }\n        if (promotion) {\n          (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.renderBoard)(game);\n        }\n        if (post && game.socket) {\n          (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.postMove)(game, promotion, game.socket);\n        }\n        return true;\n      }\n      return false;\n    },\n    moves: function moves() {\n      if (game.fiftyMoveRule > 100 || game.whitesMove !== isWhite) {\n        return [];\n      }\n      return standardMoves().filter(function (move) {\n        return isLegal(xPos, yPos, move[0], move[1], isWhite, game.board);\n      });\n    }\n  };\n}\nfunction outOfBounds(x, y) {\n  return x < 0 || y < 0 || x >= 8 || y >= 8;\n}\nfunction isLegal(fromX, fromY, toX, toY, isWhite, board) {\n  var boardClone = cloneBoard(board);\n  var piece = boardClone[fromX][fromY];\n  createPiece(piece.name, piece.isWhite, toX, toY, {\n    board: boardClone\n  });\n  boardClone[fromX][fromY] = null;\n  var kingSquare;\n  var moves = [];\n  for (var i = 0; i < 8; i++) {\n    for (var j = 0; j < 8; j++) {\n      if (boardClone[i][j]) {\n        var color = boardClone[i][j].isWhite;\n        if (boardClone[i][j].name == \"king\" && color == isWhite) {\n          kingSquare = [i, j];\n        }\n        if (color !== isWhite) {\n          var pieceMoves = boardClone[i][j].standardMoves();\n          pieceMoves.map(function (move) {\n            return moves.push(move);\n          });\n        }\n      }\n    }\n  }\n  if (kingSquare && moves.some(function (move) {\n    return move[0] === kingSquare[0] && move[1] === kingSquare[1];\n  })) {\n    return false;\n  }\n  return true;\n}\nfunction cloneBoard(board) {\n  var newBoard = _toConsumableArray(Array(8)).map(function (e) {\n    return Array(8).fill(null);\n  });\n  for (var x = 0; x < 8; x++) {\n    for (var y = 0; y < 8; y++) {\n      if (board[x][y]) {\n        createPiece(board[x][y].name, board[x][y].isWhite, x, y, {\n          board: newBoard\n        });\n      }\n    }\n  }\n  return newBoard;\n}\nfunction cloneGame(game) {\n  return {\n    board: cloneBoard(game.board),\n    div: game.div,\n    whitesMove: game.whitesMove,\n    showingWhiteSide: game.showingWhiteSide,\n    lastMove: game.lastMove,\n    lastMoveSound: game.lastMoveSound,\n    drawnArrows: [],\n    userHighlights: [],\n    fiftyMoveRule: game.fiftyMoveRule,\n    whiteState: {\n      shortCastle: game.whiteState.shortCastle,\n      longCastle: game.whiteState.longCastle\n    },\n    blackState: {\n      shortCastle: game.blackState.shortCastle,\n      longCastle: game.blackState.longCastle\n    }\n  };\n}\nfunction inCheck(game) {\n  var check = false;\n  game.board.forEach(function (row, x) {\n    row.forEach(function (square, y) {\n      if (game.board[x][y] && game.board[x][y].name === \"king\" && game.board[x][y].inCheck()) {\n        check = (0,_notation_js__WEBPACK_IMPORTED_MODULE_3__.convertLocationToNotation)(x, y);\n      }\n    });\n  });\n  return check;\n}\nfunction gameOver(game) {\n  if (game.fiftyMoveRule > 100) {\n    return {\n      result: \"Stalemate\",\n      reason: \"Fifty move rule\"\n    };\n  }\n  if (threeFoldRepetition(game)) {\n    return {\n      result: \"Stalemate\",\n      reason: \"Threefold Repetition\"\n    };\n  }\n  try {\n    var chess = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess((0,_board_js__WEBPACK_IMPORTED_MODULE_1__.gametoFEN)(game));\n    if (chess.isCheckmate()) {\n      return {\n        result: !game.whitesMove ? \"White\" : \"Black\",\n        reason: \"Checkmate\"\n      };\n    }\n    if (chess.isStalemate()) {\n      return {\n        result: \"Stalemate\",\n        reason: \"No more moves\"\n      };\n    }\n    if (chess.isInsufficientMaterial()) {\n      return {\n        result: \"Stalemate\",\n        reason: \"Insufficient material\"\n      };\n    }\n  } catch (e) {\n    console.log((0,_board_js__WEBPACK_IMPORTED_MODULE_1__.gametoFEN)(game));\n    console.log(e);\n    var gameOverObject = fallbackGameOver(game);\n    if (gameOverObject) {\n      return gameOverObject;\n    }\n  }\n  return false;\n}\nfunction fallbackGameOver(game) {\n  // This solution is too slow so I use chess.js for this\n  for (var x = 0; x < 8; x++) {\n    for (var y = 0; y < 8; y++) {\n      if (game.board[x][y] && game.board[x][y].isWhite === game.whitesMove && game.board[x][y].moves().length > 0) {\n        return false;\n      }\n    }\n  }\n  if (inCheck(game)) {\n    return {\n      result: !game.whitesMove ? \"White\" : \"Black\",\n      reason: \"Checkmate\"\n    };\n  }\n  return {\n    result: \"Stalemate\",\n    reason: \"No more moves\"\n  };\n}\nfunction threeFoldRepetition(game) {\n  var newChessGame = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.createGame)(game[\"export\"][0]);\n  var positions = [];\n  game[\"export\"].slice(1).forEach(function (UCI) {\n    var startSquare = (0,_notation_js__WEBPACK_IMPORTED_MODULE_3__.convertNotationtoLocation)(UCI.substring(0, 2).toLowerCase());\n    var endSquare = (0,_notation_js__WEBPACK_IMPORTED_MODULE_3__.convertNotationtoLocation)(UCI.substring(2, 4).toLowerCase());\n    var promotion = UCI.substring(4, 5);\n    var pieces = {\n      \"q\": \"queen\",\n      \"r\": \"rook\",\n      \"n\": \"knight\",\n      \"b\": \"bishop\"\n    };\n    newChessGame.board[startSquare[0]][startSquare[1]].move(endSquare[0], endSquare[1], promotion ? pieces[promotion.toLowerCase()] : false);\n    positions.push((0,_board_js__WEBPACK_IMPORTED_MODULE_1__.gametoFEN)(newChessGame).split(\" \")[0]);\n  });\n  var numberOfPositions = 0;\n  positions.forEach(function (position) {\n    var totalCurrentPos = positions.filter(function (pos) {\n      return pos === position;\n    }).length;\n    if (totalCurrentPos >= numberOfPositions) {\n      numberOfPositions = totalCurrentPos;\n    }\n  });\n  return numberOfPositions >= 3;\n}\nfunction createPiece(piece, isWhite, xPos, yPos, game) {\n  var _Piece;\n  var createdPiece = {};\n  var pieceInfo = {\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game\n  };\n  switch (piece) {\n    case \"pawn\":\n      createdPiece = (0,_pawn_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(pieceInfo);\n      break;\n    case \"king\":\n      createdPiece = (0,_king_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(pieceInfo);\n      break;\n    case \"knight\":\n      createdPiece = (0,_knight_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(pieceInfo);\n      break;\n    case \"rook\":\n      createdPiece = (0,_rook_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(pieceInfo);\n      break;\n    case \"bishop\":\n      createdPiece = (0,_bishop_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(pieceInfo);\n      break;\n    case \"queen\":\n      createdPiece = (0,_queen_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(pieceInfo);\n      break;\n    default:\n      createdPiece = {\n        standardMoves: function standardMoves() {\n          return [];\n        }\n      };\n      break;\n  }\n  var genericPiece = Piece((_Piece = {\n    name: piece,\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos\n  }, _defineProperty(_Piece, \"yPos\", yPos), _defineProperty(_Piece, \"standardMoves\", createdPiece.standardMoves), _defineProperty(_Piece, \"game\", game), _Piece));\n  game.board[xPos][yPos] = _objectSpread(_objectSpread({}, genericPiece), createdPiece);\n  return game.board[xPos][yPos];\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/piece.js?");

/***/ }),

/***/ "./src/chess/pieces/queen.js":
/*!***********************************!*\
  !*** ./src/chess/pieces/queen.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Queen)\n/* harmony export */ });\n/* harmony import */ var _rook_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rook.js */ \"./src/chess/pieces/rook.js\");\n/* harmony import */ var _bishop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bishop.js */ \"./src/chess/pieces/bishop.js\");\n/* harmony import */ var _piece_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./piece.js */ \"./src/chess/pieces/piece.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rook_js__WEBPACK_IMPORTED_MODULE_0__, _bishop_js__WEBPACK_IMPORTED_MODULE_1__, _piece_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_rook_js__WEBPACK_IMPORTED_MODULE_0__, _bishop_js__WEBPACK_IMPORTED_MODULE_1__, _piece_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nfunction Queen(_ref) {\n  var isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    game = _ref.game;\n  var piece = (0,_piece_js__WEBPACK_IMPORTED_MODULE_2__.Piece)({\n    name: \"queen\",\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game,\n    standardMoves: function standardMoves() {\n      var bishop = (0,_bishop_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        isWhite: isWhite,\n        xPos: xPos,\n        yPos: yPos,\n        game: game\n      });\n      var rook = (0,_rook_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        isWhite: isWhite,\n        xPos: xPos,\n        yPos: yPos,\n        game: game\n      });\n      return bishop.standardMoves().concat(rook.standardMoves());\n    }\n  });\n  return piece;\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/queen.js?");

/***/ }),

/***/ "./src/chess/pieces/rook.js":
/*!**********************************!*\
  !*** ./src/chess/pieces/rook.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rook)\n/* harmony export */ });\n/* harmony import */ var _piece_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece.js */ \"./src/chess/pieces/piece.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_piece_js__WEBPACK_IMPORTED_MODULE_0__]);\n_piece_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction Rook(_ref) {\n  var isWhite = _ref.isWhite,\n    xPos = _ref.xPos,\n    yPos = _ref.yPos,\n    game = _ref.game;\n  var piece = (0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.Piece)({\n    name: \"rook\",\n    isWhite: isWhite,\n    xPos: xPos,\n    yPos: yPos,\n    game: game,\n    standardMoves: function standardMoves() {\n      var directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n      var moves = [];\n      for (var _i = 0, _directions = directions; _i < _directions.length; _i++) {\n        var direction = _directions[_i];\n        var _direction = _slicedToArray(direction, 2),\n          dx = _direction[0],\n          dy = _direction[1];\n        var x = xPos + dx;\n        var y = yPos + dy;\n        while (!(0,_piece_js__WEBPACK_IMPORTED_MODULE_0__.outOfBounds)(x, y)) {\n          if (game.board[x][y] === null || piece.canCapture(game.board[x][y]) || game.board[x][y].name === \"passant\") {\n            moves.push([x, y, function () {\n              if (xPos === 0 && yPos === 0) {\n                game.whiteState.shortCastle = false;\n              }\n              if (xPos === 0 && yPos === 7) {\n                game.whiteState.longCastle = false;\n              }\n              if (xPos === 7 && yPos === 0) {\n                game.blackState.shortCastle = false;\n              }\n              if (xPos === 7 && yPos === 7) {\n                game.blackState.longCastle = false;\n              }\n            }]);\n            if (piece.canCapture(game.board[x][y]) && game.board[x][y].name !== \"passant\") {\n              break;\n            }\n          } else {\n            break;\n          }\n          x += dx;\n          y += dy;\n        }\n      }\n      return moves;\n    }\n  });\n  return piece;\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/pieces/rook.js?");

/***/ }),

/***/ "./src/chess/timer.js":
/*!****************************!*\
  !*** ./src/chess/timer.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChessTimer)\n/* harmony export */ });\nfunction ChessTimer(secondsLength, secondsIncrement, updateFunction, timerFinishedFunction, linkedTimer) {\n  var timer = {\n    timerStarted: new Date().getTime(),\n    timeLeft: secondsLength * 1000,\n    length: secondsLength * 1000,\n    increment: secondsIncrement * 1000,\n    isRunning: false,\n    updateFunction: updateFunction,\n    timerFinishedFunction: timerFinishedFunction,\n    linkedTimer: linkedTimer\n  };\n  timer.start = function () {\n    if (!timer.isRunning) {\n      timer.timerStarted = new Date().getTime();\n      timer.length = timer.timeLeft;\n      timer.isRunning = true;\n      updateTimer(timer);\n      setInterval(function interval() {\n        updateTimer(timer, interval);\n      }, 100);\n    }\n  };\n  timer.alternate = function () {\n    if (timer.linkedTimer && timer.linkedTimer.start && timer.linkedTimer.pause) {\n      if (timer.linkedTimer.isRunning) {\n        timer.linkedTimer.pause();\n        timer.start();\n      } else {\n        timer.linkedTimer.start();\n        timer.pause();\n      }\n    }\n  };\n  timer.pause = function () {\n    if (timer.isRunning) {\n      timer.length += timer.increment;\n      updateTimer(timer);\n      timer.isRunning = false;\n      if (updateFunction) {\n        updateFunction(timer.timeLeft);\n      }\n    }\n  };\n  return timer;\n}\nfunction updateTimer(timer, fn) {\n  if (timer.isRunning) {\n    var time = new Date().getTime();\n    timer.timeLeft = timer.length - (time - timer.timerStarted);\n    if (timer.updateFunction) {\n      timer.updateFunction(timer.timeLeft);\n    }\n    if (timer.timeLeft <= 0) {\n      if (timer.timerFinishedFunction) {\n        timer.timerFinishedFunction();\n      }\n      if (timer.updateFunction) {\n        timer.updateFunction(0);\n      }\n      timer.timeLeft = 0;\n      timer.isRunning = false;\n    }\n  } else {\n    clearInterval(fn);\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/timer.js?");

/***/ }),

/***/ "./src/game/main.js":
/*!**************************!*\
  !*** ./src/game/main.js ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTimerDiv: () => (/* binding */ createTimerDiv),\n/* harmony export */   updateToast: () => (/* binding */ updateToast)\n/* harmony export */ });\n/* harmony import */ var _game_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.css */ \"./src/game/game.css\");\n/* harmony import */ var _header_header_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../header/header.css */ \"./src/header/header.css\");\n/* harmony import */ var _footer_footer_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../footer/footer.css */ \"./src/footer/footer.css\");\n/* harmony import */ var _chess_cburnett_move_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../chess/cburnett/move.svg */ \"./src/chess/cburnett/move.svg\");\n/* harmony import */ var _chess_board_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../chess/board.js */ \"./src/chess/board.js\");\n/* harmony import */ var _websockets_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./websockets.js */ \"./src/game/websockets.js\");\n/* harmony import */ var _chess_modify_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../chess/modify.js */ \"./src/chess/modify.js\");\n/* harmony import */ var _chess_notation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../chess/notation.js */ \"./src/chess/notation.js\");\n/* harmony import */ var _chess_animations_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../chess/animations.js */ \"./src/chess/animations.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_chess_board_js__WEBPACK_IMPORTED_MODULE_4__, _websockets_js__WEBPACK_IMPORTED_MODULE_5__, _chess_modify_js__WEBPACK_IMPORTED_MODULE_6__, _chess_animations_js__WEBPACK_IMPORTED_MODULE_8__]);\n([_chess_board_js__WEBPACK_IMPORTED_MODULE_4__, _websockets_js__WEBPACK_IMPORTED_MODULE_5__, _chess_modify_js__WEBPACK_IMPORTED_MODULE_6__, _chess_animations_js__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n\n\n\n\n\n\nif (document.body.dataset.id) {\n  var gameContainer = document.querySelector('#game');\n  var urlParams = new URLSearchParams(window.location.search);\n  var isBlack = urlParams.get('black');\n  window.history.replaceState({}, document.title, \"/game/\" + document.body.dataset.id);\n  var res = await fetch(\"/api/game/\".concat(document.body.dataset.id));\n  var gameData = await res.json();\n  var game;\n  if (gameData.live) {\n    game = await (0,_websockets_js__WEBPACK_IMPORTED_MODULE_5__.existingGame)(document.body.dataset.id, gameContainer, createUpdate);\n    (0,_websockets_js__WEBPACK_IMPORTED_MODULE_5__.createTokenAndJoin)(game, isBlack).then(function (res) {\n      updateToast(res);\n    })[\"catch\"](function (error) {\n      updateToast(error);\n    });\n  } else {\n    game = (0,_chess_board_js__WEBPACK_IMPORTED_MODULE_4__.importGame)([gameData.game.fen, _toConsumableArray(gameData.game.uci.split(' '))]);\n    game.id = gameData.id;\n    game.whiteUserSpan.textContent = gameData.game.whitePlayer;\n    game.blackUserSpan.textContent = gameData.game.blackPlayer;\n    gameContainer.innerHTML = \"\";\n    gameContainer.appendChild(game.div);\n  }\n  addControls(game);\n  var whiteInfo = document.querySelector('#whiteInfo');\n  var blackInfo = document.querySelector('#blackInfo');\n  whiteInfo.prepend(game.whiteUserSpan);\n  blackInfo.prepend(game.blackUserSpan);\n  fillHistory(game, document.querySelector('ol'));\n  console.log(game);\n}\nfunction addControls(chessGame) {\n  document.addEventListener('keydown', function (e) {\n    if (e.code === \"ArrowLeft\") {\n      backButton(chessGame);\n    }\n    if (e.code === \"ArrowRight\") {\n      forwardButton(chessGame);\n    }\n    if (e.code === \"ArrowUp\") {\n      e.preventDefault();\n      startButton(chessGame);\n    }\n    if (e.code === \"ArrowDown\") {\n      e.preventDefault();\n      endButton(chessGame);\n    }\n    if (e.code === \"KeyF\") {\n      (0,_chess_modify_js__WEBPACK_IMPORTED_MODULE_6__.flipBoard)(chessGame);\n    }\n    // if(e.code === \"KeyZ\") {\n    //     undoMove(chessGame)\n    // }\n  });\n\n  document.querySelector('#end').addEventListener('click', function () {\n    return endButton(chessGame);\n  });\n  document.querySelector('#start').addEventListener('click', function () {\n    return startButton(chessGame);\n  });\n  document.querySelector('#back').addEventListener('click', function () {\n    return backButton(chessGame);\n  });\n  document.querySelector('#forward').addEventListener('click', function () {\n    return forwardButton(chessGame);\n  });\n  document.querySelector('#flip').addEventListener('click', function () {\n    return (0,_chess_modify_js__WEBPACK_IMPORTED_MODULE_6__.flipBoard)(chessGame);\n  });\n  var chessBoard = document.querySelector('#game');\n  if (chessBoard) {\n    chessBoard.addEventListener('wheel', function (e) {\n      e.preventDefault();\n      if (e.deltaY > 0) {\n        forwardButton(chessGame);\n      } else {\n        backButton(chessGame);\n      }\n    });\n  }\n  // document.querySelector('#takeback').addEventListener('click', () => undoMove(chessGame))\n}\n\nfunction endButton(game) {\n  (0,_chess_modify_js__WEBPACK_IMPORTED_MODULE_6__.viewCurrentGame)(game);\n  var nodes = document.querySelectorAll('ol > li > span');\n  if (nodes[nodes.length - 1].innerHTML !== \"\") {\n    nodes[nodes.length - 1].classList.add('active');\n  } else {\n    nodes[nodes.length - 2].classList.add('active');\n  }\n  document.querySelector('ol').scrollTo({\n    top: document.querySelector('ol').scrollHeight,\n    behavior: 'smooth'\n  });\n}\nfunction startButton(game) {\n  (0,_chess_modify_js__WEBPACK_IMPORTED_MODULE_6__.viewStartHistory)(game);\n  document.querySelectorAll('ol > li > span').forEach(function (span) {\n    span.classList.remove('active');\n  });\n  document.querySelector('ol').scrollTo({\n    top: 0,\n    behavior: 'smooth'\n  });\n}\nfunction backButton(game) {\n  var currentHistory = game.history.length - game.timeline - 1;\n  goToHistory(game, currentHistory - 1);\n}\nfunction forwardButton(game) {\n  var currentHistory = game.history.length - game.timeline - 1;\n  goToHistory(game, currentHistory + 1);\n}\nfunction createTimerDiv(game, isWhite, div) {\n  var timer = isWhite ? game.whiteClock : game.blackClock;\n  updateTimer(timer.timeLeft, div);\n  timer.updateFunction = function (time) {\n    return updateTimer(time, div);\n  };\n  return timer;\n}\nfunction createUpdate(game) {\n  createTimerDiv(game, true, document.querySelector('#whiteTimer'));\n  createTimerDiv(game, false, document.querySelector('#blackTimer'));\n}\nfunction updateTimer(time, div) {\n  var minutes = Math.floor(time / 60000);\n  var seconds = Math.floor((time - minutes * 60000) / 1000);\n  var milliseconds = Math.floor((time - minutes * 60000 - seconds * 1000) / 100);\n  div.innerText = \"\".concat(minutes, \":\").concat(seconds, \".\").concat(milliseconds);\n}\nfunction flagTimer(timer, color) {\n  var div = document.querySelector(\"#\".concat(color, \"Timer\"));\n  timer.pause();\n  updateTimer(0, div);\n  // TODO: Add flag animation\n}\n\nfunction fillHistory(game, ol) {\n  ol.innerHTML = \"\";\n  var history = game.history.slice(1);\n  history.push(game);\n  var moveArr = [\"\", \"\"];\n  history.forEach(function (gameState, i) {\n    var prevBoard = game.history[i].board;\n    if (!moveArr[0]) {\n      moveArr[0] = (0,_chess_notation_js__WEBPACK_IMPORTED_MODULE_7__.lastMoveToNotation)(gameState, prevBoard);\n    } else {\n      moveArr[1] = (0,_chess_notation_js__WEBPACK_IMPORTED_MODULE_7__.lastMoveToNotation)(gameState, prevBoard);\n      var li = document.createElement('li');\n      var numSpan = document.createElement('span');\n      var moveSpan = document.createElement('span');\n      moveSpan.addEventListener('click', function (e) {\n        return goToHistory(game, i - 1);\n      });\n      moveSpan.setAttribute('history-index', i - 1);\n      var moveSpan2 = document.createElement('span');\n      moveSpan2.addEventListener('click', function (e) {\n        return goToHistory(game, i);\n      });\n      moveSpan2.setAttribute('history-index', i);\n      var number = Math.floor(i / 2) + 1;\n      numSpan.innerText = \"\".concat(number, \".\");\n      moveSpan.innerText = moveArr[0];\n      moveSpan2.innerText = moveArr[1];\n      li.appendChild(numSpan);\n      li.appendChild(moveSpan);\n      li.appendChild(moveSpan2);\n      ol.appendChild(li);\n      moveArr[0] = \"\";\n      moveArr[1] = \"\";\n    }\n  });\n  if (moveArr[0]) {\n    var li = document.createElement('li');\n    var numSpan = document.createElement('span');\n    var moveSpan = document.createElement('span');\n    moveSpan.addEventListener('click', function (e) {\n      return goToHistory(game, history.length - 1);\n    });\n    moveSpan.setAttribute('history-index', history.length - 1);\n    moveSpan.classList.add('active');\n    var emptySpan = document.createElement('span');\n    var number = Math.floor(history.length / 2) + 1;\n    numSpan.innerText = \"\".concat(number, \".\");\n    moveSpan.innerText = moveArr[0];\n    li.appendChild(numSpan);\n    li.appendChild(moveSpan);\n    li.appendChild(emptySpan);\n    ol.appendChild(li);\n  } else {\n    var nodes = document.querySelectorAll('ol > li > span');\n    nodes[nodes.length - 1].classList.add('active');\n  }\n}\nfunction goToHistory(game, historyIndex) {\n  var prevHistory = game.timeline;\n  game.timeline = game.history.length - (historyIndex + 1);\n  if (game.timeline <= 0) {\n    game.timeline = 0;\n    historyIndex = game.history.length - 1;\n  }\n  if (game.timeline >= game.history.length) {\n    game.timeline = game.history.length;\n    historyIndex -= 1;\n  }\n  (0,_chess_animations_js__WEBPACK_IMPORTED_MODULE_8__.animateHistory)(game, prevHistory);\n  document.querySelectorAll('ol > li > span').forEach(function (span) {\n    span.classList.remove('active');\n  });\n  var activeSpan = document.querySelector(\"[history-index=\\\"\".concat(historyIndex, \"\\\"]\"));\n  if (activeSpan) {\n    activeSpan.classList.add('active');\n    activeSpan.scrollIntoView({\n      behavior: 'smooth',\n      block: 'nearest'\n    });\n  }\n}\nfunction updateToast(text) {\n  var toast = document.querySelector('#toast');\n  if (!toast) {\n    return;\n  }\n  if (text.result) {\n    if (text.result === \"Stalemate\") {\n      toast.innerHTML = \"Game ended in Stalemate due to \".concat(text.reason, \".\");\n    } else {\n      toast.innerHTML = \"\".concat(text.result, \" has won due to \").concat(text.reason);\n    }\n  } else {\n    toast.innerHTML = text;\n  }\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://my-webpack-project/./src/game/main.js?");

/***/ }),

/***/ "./src/game/random.js":
/*!****************************!*\
  !*** ./src/game/random.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ randomMove)\n/* harmony export */ });\nfunction randomMove(game, isWhite) {\n  var possibleMoves = [];\n  game.board.forEach(function (row) {\n    row.forEach(function (piece) {\n      if (piece && piece.isWhite === isWhite) {\n        piece.moves().forEach(function (move) {\n          possibleMoves.push([[piece.xPos, piece.yPos], move]);\n        });\n      }\n    });\n  });\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve(possibleMoves.length ? possibleMoves[Math.floor(Math.random() * possibleMoves.length)] : false);\n    }, 1000);\n  });\n}\n\n//# sourceURL=webpack://my-webpack-project/./src/game/random.js?");

/***/ }),

/***/ "./src/game/websockets.js":
/*!********************************!*\
  !*** ./src/game/websockets.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTokenAndJoin: () => (/* binding */ createTokenAndJoin),\n/* harmony export */   createWSGame: () => (/* binding */ createWSGame),\n/* harmony export */   createWebSocket: () => (/* binding */ createWebSocket),\n/* harmony export */   \"default\": () => (/* binding */ newGame),\n/* harmony export */   existingGame: () => (/* binding */ existingGame),\n/* harmony export */   joinGame: () => (/* binding */ joinGame)\n/* harmony export */ });\n/* harmony import */ var _chess_board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chess/board */ \"./src/chess/board.js\");\n/* harmony import */ var _chess_modify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chess/modify */ \"./src/chess/modify.js\");\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main.js */ \"./src/game/main.js\");\n/* harmony import */ var _chess_timer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../chess/timer.js */ \"./src/chess/timer.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_chess_board__WEBPACK_IMPORTED_MODULE_0__, _chess_modify__WEBPACK_IMPORTED_MODULE_1__, _main_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_chess_board__WEBPACK_IMPORTED_MODULE_0__, _chess_modify__WEBPACK_IMPORTED_MODULE_1__, _main_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\nfunction createWSGame(_x, _x2) {\n  return _createWSGame.apply(this, arguments);\n}\nfunction _createWSGame() {\n  _createWSGame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fen, timeControl) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n            var chessGame = (0,_chess_board__WEBPACK_IMPORTED_MODULE_0__.createGame)(fen);\n            try {\n              var socket = new WebSocket('ws://localhost:8080');\n              socket.onopen = function () {\n                socket.send(JSON.stringify({\n                  fen: fen ? fen : \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\",\n                  timeControl: timeControl ? timeControl : {\n                    seconds: 300,\n                    increment: 1\n                  }\n                }));\n              };\n              socket.onmessage = function (event) {\n                chessGame.id = event.data;\n                resolve(chessGame.id);\n              };\n            } catch (e) {\n              reject(e);\n            }\n          }));\n        case 1:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _createWSGame.apply(this, arguments);\n}\nfunction createWebSocket(_x3, _x4) {\n  return _createWebSocket.apply(this, arguments);\n}\nfunction _createWebSocket() {\n  _createWebSocket = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id, timeFunction) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n            var socket = new WebSocket('ws://localhost:8080');\n            socket.onopen = function () {\n              socket.send(JSON.stringify({\n                id: id\n              }));\n            };\n            socket.addEventListener('message', fetchGame);\n            socket.onerror = function (error) {\n              reject(error);\n            };\n            function fetchGame(e) {\n              var data = JSON.parse(e.data);\n              if (data.exportedGame) {\n                var importedGame = (0,_chess_board__WEBPACK_IMPORTED_MODULE_0__.importGame)(data.exportedGame);\n                importedGame.id = data.id;\n                importedGame.socket = socket;\n                if (importedGame && importedGame.div) {\n                  var whiteClock;\n                  var blackClock;\n                  socket.addEventListener('message', function (e) {\n                    var response = JSON.parse(e.data);\n                    if (response.uci) {\n                      var lastMove = importedGame.lastMove ? importedGame.lastMove[0] + importedGame.lastMove[1] : \"\";\n                      if (response.invalid && response.uci.slice(0, 4) === lastMove) {\n                        (0,_main_js__WEBPACK_IMPORTED_MODULE_2__.updateToast)(\"Server rejected move. Try refreshing?\");\n                        (0,_chess_modify__WEBPACK_IMPORTED_MODULE_1__.undoMove)(importedGame);\n                        return;\n                      }\n                      if (response.uci.slice(0, 4) !== lastMove && !response.invalid) {\n                        (0,_chess_board__WEBPACK_IMPORTED_MODULE_0__.fetchMove)(importedGame, response.uci, true);\n                        if (importedGame.timer) {\n                          importedGame.timer.alternate();\n                        }\n                      }\n                    }\n                    if (response.result) {\n                      importedGame.result = {\n                        result: response.result,\n                        reason: response.reason\n                      };\n                      if (whiteClock && blackClock) {\n                        whiteClock.pause();\n                        blackClock.pause();\n                      }\n                      (0,_main_js__WEBPACK_IMPORTED_MODULE_2__.updateToast)(importedGame.result);\n                      (0,_chess_modify__WEBPACK_IMPORTED_MODULE_1__.changePlayerSide)(importedGame, true);\n                    }\n                    if (response.whiteUser) {\n                      importedGame.whiteUserSpan.textContent = response.whiteUser;\n                    }\n                    if (response.blackUser) {\n                      importedGame.blackUserSpan.textContent = response.blackUser;\n                    }\n                    if (response.whiteClock && response.blackClock) {\n                      whiteClock = (0,_chess_timer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(response.whiteClock, response.increment);\n                      blackClock = (0,_chess_timer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(response.blackClock, response.increment);\n                      importedGame.whiteClock = whiteClock;\n                      importedGame.blackClock = blackClock;\n                      if (timeFunction) {\n                        timeFunction(importedGame);\n                      }\n                      if (response.activeClock) {\n                        response.activeClock === \"white\" ? whiteClock.start() : blackClock.start();\n                      }\n                    }\n                    if (response.startClock) {\n                      response.startClock === \"white\" ? whiteClock.start() : blackClock.start();\n                    }\n                    if (response.stopClock) {\n                      response.stopClock === \"white\" ? whiteClock.pause() : blackClock.pause();\n                    }\n                    if (response.update) {\n                      if (response.update.whiteClock && whiteClock) {\n                        whiteClock.length = response.update.whiteClock.length;\n                        whiteClock.timerStarted = response.update.whiteClock.timerStarted;\n                      }\n                      if (response.update.blackClockUpdate && blackClock) {\n                        blackClock.length = response.update.blackClockUpdate.length;\n                        blackClock.timerStarted = response.update.blackClockUpdate.timerStarted;\n                      }\n                    }\n                    console.log(response);\n                  });\n                  socket.removeEventListener('message', fetchGame);\n                  resolve(importedGame);\n                }\n              }\n            }\n          }));\n        case 1:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _createWebSocket.apply(this, arguments);\n}\nfunction existingGame(_x5, _x6, _x7) {\n  return _existingGame.apply(this, arguments);\n}\nfunction _existingGame() {\n  _existingGame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id, parentDiv, timeFunction) {\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n            // id must be string if not weird things happen\n            createWebSocket(\"\".concat(id), timeFunction).then(function (game) {\n              if (parentDiv) {\n                parentDiv.innerHTML = \"\";\n                parentDiv.appendChild(game.div);\n              }\n              resolve(game);\n            })[\"catch\"](function (error) {\n              reject(error);\n            });\n          }));\n        case 1:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _existingGame.apply(this, arguments);\n}\nfunction newGame(_x8, _x9) {\n  return _newGame.apply(this, arguments);\n}\nfunction _newGame() {\n  _newGame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(fen, timeControl) {\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          return _context5.abrupt(\"return\", new Promise(function (resolve, reject) {\n            createWSGame(fen, timeControl).then(function (id) {\n              createWebSocket(id).then(function (game) {\n                resolve(game);\n              })[\"catch\"](function (error) {\n                reject(error);\n              });\n            })[\"catch\"](function (error) {\n              reject(error);\n            });\n          }));\n        case 1:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return _newGame.apply(this, arguments);\n}\nfunction joinGame(_x10, _x11) {\n  return _joinGame.apply(this, arguments);\n}\nfunction _joinGame() {\n  _joinGame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(game, joinAsBlack) {\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          return _context6.abrupt(\"return\", new Promise(function (resolve, reject) {\n            console.log(joinAsBlack);\n            game.socket.send(JSON.stringify({\n              token: localStorage.getItem('token'),\n              id: game.id,\n              joinAsBlack: joinAsBlack\n            }));\n            game.socket.addEventListener('message', sendSide);\n            function sendSide(e) {\n              setTimeout(function () {\n                reject(\"Could not join game\");\n                game.socket.removeEventListener('message', sendSide);\n              }, 5000);\n              var response = JSON.parse(e.data);\n              if (response.isWhite !== undefined) {\n                resolve(response.isWhite);\n                game.socket.removeEventListener('message', sendSide);\n              }\n            }\n          }));\n        case 1:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return _joinGame.apply(this, arguments);\n}\nfunction createTokenAndJoin(game, joinAsBlack) {\n  return new Promise(function (resolve, reject) {\n    var auth;\n    if (localStorage.getItem('token')) {\n      auth = localStorage.getItem('token');\n    }\n    fetch(\"/token\", {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer ' + auth\n      }\n    }).then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(res) {\n        var statusCode;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              statusCode = res.status;\n              _context.next = 3;\n              return res.json();\n            case 3:\n              res = _context.sent;\n              res.statusCode = statusCode;\n              return _context.abrupt(\"return\", res);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function (_x12) {\n        return _ref.apply(this, arguments);\n      };\n    }()).then(function (res) {\n      if (res.statusCode === 401) {\n        resolve(\"You are spectating. Log in to play.\");\n        return;\n      }\n      localStorage.setItem('token', res.token);\n      joinGame(game, joinAsBlack).then(function (isWhite) {\n        game.playerIsWhite = isWhite;\n        var spectating = isWhite == null;\n        var toastString = \"You are \" + (spectating ? \"spectating\" : \"playing as \".concat(isWhite ? \"white\" : \"black\"));\n        if (isWhite === false) {\n          (0,_chess_modify__WEBPACK_IMPORTED_MODULE_1__.flipBoard)(game);\n        }\n        resolve(toastString);\n      })[\"catch\"](function (err) {\n        reject(err);\n      });\n    })[\"catch\"](function (err) {\n      reject(err);\n    });\n  });\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://my-webpack-project/./src/game/websockets.js?");

/***/ }),

/***/ "./src/footer/footer.css":
/*!*******************************!*\
  !*** ./src/footer/footer.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://my-webpack-project/./src/footer/footer.css?");

/***/ }),

/***/ "./src/game/game.css":
/*!***************************!*\
  !*** ./src/game/game.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://my-webpack-project/./src/game/game.css?");

/***/ }),

/***/ "./src/header/header.css":
/*!*******************************!*\
  !*** ./src/header/header.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://my-webpack-project/./src/header/header.css?");

/***/ }),

/***/ "./src/chess/cburnett/bB.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/bB.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/e196dd569ecbcb92d569.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/bB.svg?");

/***/ }),

/***/ "./src/chess/cburnett/bK.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/bK.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/c83f5581968cfa1416d4.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/bK.svg?");

/***/ }),

/***/ "./src/chess/cburnett/bN.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/bN.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/2806967ff884b67af8fc.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/bN.svg?");

/***/ }),

/***/ "./src/chess/cburnett/bP.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/bP.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/0bac57fcee185c845528.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/bP.svg?");

/***/ }),

/***/ "./src/chess/cburnett/bQ.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/bQ.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/e475a365a63ab9c3b484.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/bQ.svg?");

/***/ }),

/***/ "./src/chess/cburnett/bR.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/bR.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/48665a8ce082e5f12710.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/bR.svg?");

/***/ }),

/***/ "./src/chess/cburnett/move.svg":
/*!*************************************!*\
  !*** ./src/chess/cburnett/move.svg ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/442b87d656904e4eba23.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/move.svg?");

/***/ }),

/***/ "./src/chess/cburnett/wB.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/wB.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/b2002308f81e96903120.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/wB.svg?");

/***/ }),

/***/ "./src/chess/cburnett/wK.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/wK.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/ae4879833ee0111ba3b2.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/wK.svg?");

/***/ }),

/***/ "./src/chess/cburnett/wN.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/wN.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/dc9544a72b2cf7a92579.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/wN.svg?");

/***/ }),

/***/ "./src/chess/cburnett/wP.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/wP.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/2062ce2d4d0e8d018369.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/wP.svg?");

/***/ }),

/***/ "./src/chess/cburnett/wQ.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/wQ.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/30871ebbc0ad7f46a1c7.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/wQ.svg?");

/***/ }),

/***/ "./src/chess/cburnett/wR.svg":
/*!***********************************!*\
  !*** ./src/chess/cburnett/wR.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/images/c051a30b157b9deadd0d.svg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/cburnett/wR.svg?");

/***/ }),

/***/ "./src/chess/sounds/Capture.ogg":
/*!**************************************!*\
  !*** ./src/chess/sounds/Capture.ogg ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/sounds/4c0d6b27175ec63ec634.ogg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/sounds/Capture.ogg?");

/***/ }),

/***/ "./src/chess/sounds/Check.wav":
/*!************************************!*\
  !*** ./src/chess/sounds/Check.wav ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/sounds/08e1bc366728c6a042c1.wav\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/sounds/Check.wav?");

/***/ }),

/***/ "./src/chess/sounds/Move.ogg":
/*!***********************************!*\
  !*** ./src/chess/sounds/Move.ogg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"assets/sounds/5a58dd80a641cfdf5fb0.ogg\";\n\n//# sourceURL=webpack://my-webpack-project/./src/chess/sounds/Move.ogg?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../../";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/game/main.js");
/******/ 	
/******/ })()
;